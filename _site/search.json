[
  {
    "objectID": "portfolio.html",
    "href": "portfolio.html",
    "title": "Portfolio",
    "section": "",
    "text": "Advanced Cartography ProjectPDF\n  \n  Invasive Species MapPDF\n  \n  AGU PosterPDF\n    \n  LANDIS-II Output MapsPDF\n  \n  Graphical Abstract of Albedo Vegetation FeedbacksPDF\n  \n  Advanced Cartography SubmissionPDF\n    \n  Advanced Cartography SubmissionPDF"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Wesley Rancher",
    "section": "",
    "text": "I’m a graduate researcher at the University of Oregon, where I use GIS, remote sensing, and data science to investigate landscape change across different spatial and temporal scales, with a focus on boreal and temperate ecosystems. I recently completed a Master’s degree in Geography, and my thesis investigated 25 years of forest composition change in Alaska using satellite imagery, machine learning, and simulation modeling.\n\n\n\nCode snippets for spatial data analysis using R\nLab materials I’ve developed to support remote sensing and GIS instruction\nMaps, posters, and links to research articles\n\n\n\n\n\nM.S. in Geography\nUniversity of Oregon | Eugene, OR\nB.A. in Environmental Studies, Geography, and Philosophy\nOhio Wesleyan University | Delaware, OH"
  },
  {
    "objectID": "index.html#on-this-site-youll-find",
    "href": "index.html#on-this-site-youll-find",
    "title": "Wesley Rancher",
    "section": "",
    "text": "Code snippets for spatial data analysis using R\nLab materials I’ve developed to support remote sensing and GIS instruction\nMaps, posters, and links to research articles"
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "Wesley Rancher",
    "section": "",
    "text": "M.S. in Geography\nUniversity of Oregon | Eugene, OR\nB.A. in Environmental Studies, Geography, and Philosophy\nOhio Wesleyan University | Delaware, OH"
  },
  {
    "objectID": "code/RandomForestAccuracy/index.html",
    "href": "code/RandomForestAccuracy/index.html",
    "title": "Fitting Random Forests",
    "section": "",
    "text": "Libraries\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(stringr)\nlibrary(purrr)\nlibrary(tidymodels)\nlibrary(randomForest)\nlibrary(rlang)\nlibrary(missForest)\n\nClean training data\n\n#annual csvs\nfiles &lt;- list.files(\"data/processed/csv/\", pattern = \"pixel-vals-fire\", full.names = TRUE)\n\nclean_df &lt;- function(file){\n  #read in\n  df &lt;- read.csv(file)\n\n  #convert geo column to lat/lon\n  matches &lt;- regmatches(df$.geo, regexec('\"coordinates\":\\\\[([-0-9.]+),([-0-9.]+)\\\\]', df$.geo))\n  coords &lt;- do.call(rbind, matches)\n  \n  #add lat long and convert time since fire to categorical\n  df_clean &lt;- df %&gt;% \n    mutate(lon = as.numeric(coords[, 2]),\n           lat = as.numeric(coords[, 3]),\n           tsf_0_5 = tsf &gt;=0 & tsf &lt; 5,\n           tsf_5_10 = tsf &gt;=5 & tsf &lt; 10,\n           tsf_10_15 = tsf &gt;=10 & tsf &lt; 15,\n           tsf_15_20 = tsf &gt;=15 & tsf &lt; 20)%&gt;%\n    select(-.geo, -system.index, -PSP, -Year, -tsf, \n           -all_of(starts_with(\"severity\")), -SPP_count, -total_fires)\n  \n  if (ncol(df_clean)==38){\n    return(df_clean)\n  }\n}\n\n#apply the function and bind into one dataframe\nclean_training_dfs &lt;- lapply(files, clean_df) %&gt;% compact()\ntraining_df &lt;- bind_rows(clean_training_dfs)\n\nImputing missing values with random forest\n\n# Columns to ignore\nignore_cols &lt;- c(\"Biogm2\", \"Species\", \"tsf_0_5\", \"tsf_5_10\", \"tsf_10_15\", \"tsf_15_20\")\n\n# Split the dataframe\ndf_to_impute &lt;- training_df[, !(names(training_df) %in% ignore_cols)]\ndf_ignored &lt;- training_df[, (names(training_df) %in% ignore_cols)]\n\n# miss forest on missing data columns\nset.seed(614)\nimputed_result &lt;- missForest(df_to_impute)\ndf_imputed &lt;- imputed_result$ximp\n\n# recombine\ntraining_df_imputed &lt;- cbind(df_ignored, df_imputed)\n# reorder columns\ntraining_df_imputed &lt;- training_df_imputed[, names(training_df)]\n#write.csv(training_df_imputed, \"data/processed/csv/training_df_imputed.csv\", row.names = FALSE)\n\nModel fitting function (species specific)\n\nspecies &lt;- c(\"black spruce\", \"white spruce\", \"resin birch\", \"quaking aspen\")\n\ntrain_model &lt;- function(df, species, response=\"Biogm2\") {\n  print(paste0(\"running model for: \", species))\n  \n  #filter to one species\n  training_df_one_spp &lt;- training_df_imputed %&gt;% filter(Species == species)\n  predictors &lt;- setdiff(names(training_df_one_spp), c(\"Species\", \"Biogm2\"))#36 before screening\n  formula &lt;- as.formula(paste(response, \"~\", paste(predictors, collapse = \"+\")))\n  \n  #tidy models recipe (swapping in entire dataset)\n  recipe &lt;- recipe(formula = formula, data = training_df_one_spp) %&gt;% \n    step_nzv(all_predictors()) %&gt;%\n    step_corr(all_numeric_predictors(), threshold = 0.80, use = \"pairwise.complete.obs\", method = \"pearson\") %&gt;%\n    step_impute_mean(all_numeric_predictors())%&gt;%#make sure the recipe can handle NAs\n    step_normalize(all_numeric_predictors())\n    \n  #grid search for optimal parms\n  model_specs &lt;- rand_forest(mtry = tune(), \n                             trees = tune(),\n                             min_n = tune()) %&gt;% set_mode(\"regression\") %&gt;% set_engine(\"randomForest\", proximity = TRUE)\n  \n  grid_parms &lt;- expand.grid(mtry = seq(5, 10, 5), \n                            trees = seq(300,800,250), \n                            min_n = seq(1, 12, 6))\n  \n  #cross validation\n  nfold &lt;- 5\n  print(paste0(\"performing cross validation across \", nfold, \" folds\"))\n  pv_folds &lt;- vfold_cv(training_df_one_spp, v = nfold, strata = all_of(response))\n\n  #pull workflow results\n  tuned_results &lt;- workflow() %&gt;% add_recipe(recipe) %&gt;% add_model(model_specs) %&gt;% \n    tune_grid(resamples = pv_folds, grid = grid_parms, metrics = metric_set(rmse, rsq, mae))\n  autoplot(tuned_results)\n  best_params &lt;- select_best(tuned_results, metric=\"rmse\")\n  wflow &lt;- finalize_workflow(workflow() %&gt;% add_recipe(recipe) %&gt;% add_model(model_specs), best_params)\n  \n  #fit across the resamples\n  fit &lt;- fit_resamples(wflow, resamples = pv_folds, metrics = metric_set(rmse, rsq, mae))\n  mean_rmse &lt;- collect_metrics(fit) %&gt;% filter(.metric == \"rmse\") %&gt;% pull(mean)\n  mean_rsq &lt;- collect_metrics(fit) %&gt;% filter(.metric == \"rsq\") %&gt;% pull(mean)\n  \n  #print accuracy across resamples\n  print(paste(\"Mean RMSE across folds: \", mean_rmse))\n  print(paste(\"Mean R² across folds: \", mean_rsq))\n  \n  #pull out-of-fold predictions for accuracy plot\n  ctrl &lt;- control_resamples(save_pred=TRUE)\n  resample_results &lt;- wflow %&gt;% \n    fit_resamples(resamples = pv_folds, control = ctrl)\n  all_preds &lt;- resample_results %&gt;%\n    collect_predictions() %&gt;%\n    mutate(Species = species)\n  write.csv(all_preds, paste0(\"data/processed/csv/folded_pred_vs_obs_\", \n                             gsub(\" \", \"_\", species), \".csv\"))\n  \n  #store and save final fit\n  final_fit &lt;- fit(wflow, training_df_one_spp)\n  filename &lt;- paste0(\"models/final_fit_\", gsub(\" \", \"_\", species), \".rds\")\n  #saveRDS(final_fit, file = filename)\n  print(paste(\"Model saved to:\", filename))\n  \n  return(list(model = final_fit, \n              species = species, \n              mean_rmse = mean_rmse, \n              mean_rsq = mean_rsq))\n}\n\n#run the models\nmodel_output &lt;- lapply(species, function(spp){train_model(training_df_imputed,species=spp)})\n\nPrinting model accuracy metrics\n\ncv_summary &lt;- map_dfr(model_output, function(x) {\n  tibble(\n    Species = x$species,\n    RMSE_cv = x$mean_rmse,\n    R2_cv = x$mean_rsq\n  )\n})"
  },
  {
    "objectID": "code/VariableImportance/index.html",
    "href": "code/VariableImportance/index.html",
    "title": "Fitting Random Forests",
    "section": "",
    "text": "Libraries\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(stringr)\nlibrary(purrr)\nlibrary(tidymodels)\nlibrary(randomForest)\nlibrary(rlang)\nlibrary(missForest)\n\nClean training data\n\n#annual csvs\nfiles &lt;- list.files(\"data/processed/csv/\", pattern = \"pixel-vals-fire\", full.names = TRUE)\n\nclean_df &lt;- function(file){\n  #read in\n  df &lt;- read.csv(file)\n\n  #convert geo column to lat/lon\n  matches &lt;- regmatches(df$.geo, regexec('\"coordinates\":\\\\[([-0-9.]+),([-0-9.]+)\\\\]', df$.geo))\n  coords &lt;- do.call(rbind, matches)\n  \n  #add lat long and convert time since fire to categorical\n  df_clean &lt;- df %&gt;% \n    mutate(lon = as.numeric(coords[, 2]),\n           lat = as.numeric(coords[, 3]),\n           tsf_0_5 = tsf &gt;=0 & tsf &lt; 5,\n           tsf_5_10 = tsf &gt;=5 & tsf &lt; 10,\n           tsf_10_15 = tsf &gt;=10 & tsf &lt; 15,\n           tsf_15_20 = tsf &gt;=15 & tsf &lt; 20)%&gt;%\n    select(-.geo, -system.index, -PSP, -Year, -tsf, \n           -all_of(starts_with(\"severity\")), -SPP_count, -total_fires)\n  \n  if (ncol(df_clean)==38){\n    return(df_clean)\n  }\n}\n\n#apply the function and bind into one dataframe\nclean_training_dfs &lt;- lapply(files, clean_df) %&gt;% compact()\ntraining_df &lt;- bind_rows(clean_training_dfs)\n\nImputing missing values with random forest\n\n# Columns to ignore\nignore_cols &lt;- c(\"Biogm2\", \"Species\", \"tsf_0_5\", \"tsf_5_10\", \"tsf_10_15\", \"tsf_15_20\")\n\n# Split the dataframe\ndf_to_impute &lt;- training_df[, !(names(training_df) %in% ignore_cols)]\ndf_ignored &lt;- training_df[, (names(training_df) %in% ignore_cols)]\n\n# miss forest on missing data columns\nset.seed(614)\nimputed_result &lt;- missForest(df_to_impute)\ndf_imputed &lt;- imputed_result$ximp\n\n# recombine\ntraining_df_imputed &lt;- cbind(df_ignored, df_imputed)\n# reorder columns\ntraining_df_imputed &lt;- training_df_imputed[, names(training_df)]\n#write.csv(training_df_imputed, \"data/processed/csv/training_df_imputed.csv\", row.names = FALSE)\n\nModel fitting function (species specific)\n\nspecies &lt;- c(\"black spruce\", \"white spruce\", \"resin birch\", \"quaking aspen\")\n\ntrain_model &lt;- function(df, species, response=\"Biogm2\") {\n  print(paste0(\"running model for: \", species))\n  \n  #filter to one species\n  training_df_one_spp &lt;- training_df_imputed %&gt;% filter(Species == species)\n  predictors &lt;- setdiff(names(training_df_one_spp), c(\"Species\", \"Biogm2\"))#36 before screening\n  formula &lt;- as.formula(paste(response, \"~\", paste(predictors, collapse = \"+\")))\n  \n  #tidy models recipe (swapping in entire dataset)\n  recipe &lt;- recipe(formula = formula, data = training_df_one_spp) %&gt;% \n    step_nzv(all_predictors()) %&gt;%\n    step_corr(all_numeric_predictors(), threshold = 0.80, use = \"pairwise.complete.obs\", method = \"pearson\") %&gt;%\n    step_impute_mean(all_numeric_predictors())%&gt;%#make sure the recipe can handle NAs\n    step_normalize(all_numeric_predictors())\n    \n  #grid search for optimal parms\n  model_specs &lt;- rand_forest(mtry = tune(), \n                             trees = tune(),\n                             min_n = tune()) %&gt;% set_mode(\"regression\") %&gt;% set_engine(\"randomForest\", proximity = TRUE)\n  \n  grid_parms &lt;- expand.grid(mtry = seq(5, 10, 5), \n                            trees = seq(300,800,250), \n                            min_n = seq(1, 12, 6))\n  \n  #cross validation\n  nfold &lt;- 5\n  print(paste0(\"performing cross validation across \", nfold, \" folds\"))\n  pv_folds &lt;- vfold_cv(training_df_one_spp, v = nfold, strata = all_of(response))\n\n  #pull workflow results\n  tuned_results &lt;- workflow() %&gt;% add_recipe(recipe) %&gt;% add_model(model_specs) %&gt;% \n    tune_grid(resamples = pv_folds, grid = grid_parms, metrics = metric_set(rmse, rsq, mae))\n  autoplot(tuned_results)\n  best_params &lt;- select_best(tuned_results, metric=\"rmse\")\n  wflow &lt;- finalize_workflow(workflow() %&gt;% add_recipe(recipe) %&gt;% add_model(model_specs), best_params)\n  \n  #fit across the resamples\n  fit &lt;- fit_resamples(wflow, resamples = pv_folds, metrics = metric_set(rmse, rsq, mae))\n  mean_rmse &lt;- collect_metrics(fit) %&gt;% filter(.metric == \"rmse\") %&gt;% pull(mean)\n  mean_rsq &lt;- collect_metrics(fit) %&gt;% filter(.metric == \"rsq\") %&gt;% pull(mean)\n  \n  #print accuracy across resamples\n  print(paste(\"Mean RMSE across folds: \", mean_rmse))\n  print(paste(\"Mean R² across folds: \", mean_rsq))\n  \n  #pull out-of-fold predictions for accuracy plot\n  ctrl &lt;- control_resamples(save_pred=TRUE)\n  resample_results &lt;- wflow %&gt;% \n    fit_resamples(resamples = pv_folds, control = ctrl)\n  all_preds &lt;- resample_results %&gt;%\n    collect_predictions() %&gt;%\n    mutate(Species = species)\n  write.csv(all_preds, paste0(\"data/processed/csv/folded_pred_vs_obs_\", \n                             gsub(\" \", \"_\", species), \".csv\"))\n  \n  #store and save final fit\n  final_fit &lt;- fit(wflow, training_df_one_spp)\n  filename &lt;- paste0(\"models/final_fit_\", gsub(\" \", \"_\", species), \".rds\")\n  #saveRDS(final_fit, file = filename)\n  print(paste(\"Model saved to:\", filename))\n  \n  return(list(model = final_fit, \n              species = species, \n              mean_rmse = mean_rmse, \n              mean_rsq = mean_rsq))\n}\n\n#run the models\nmodel_output &lt;- lapply(species, function(spp){train_model(training_df_imputed,species=spp)})\n\nPrinting model accuracy metrics\n\ncv_summary &lt;- map_dfr(model_output, function(x) {\n  tibble(\n    Species = x$species,\n    RMSE_cv = x$mean_rmse,\n    R2_cv = x$mean_rsq\n  )\n})"
  },
  {
    "objectID": "code/ContrastStretching/index.html",
    "href": "code/ContrastStretching/index.html",
    "title": "Constrast stretching",
    "section": "",
    "text": "Let’s read in a raster and set a color palette to visualize by. This example file is a modified normalized difference water index image within interior Alaska.\n\nlibrary(terra)\n\nterra 1.8.5\n\n\n\ncolors &lt;- colorRampPalette(c(\"white\", \"lightblue\", \n                             \"blue\", \"darkblue\", \"black\"))(100)\nr &lt;- rast(\"../FullComp_Dalton_2015.tif\", lyr = 24)\nplot(r, col = colors)\n\n\n\n\n\n\n\n\nLooks great. Now if we want to increase the contrast between different pixel values. We can do this\n\n# contrast stretch\np_low &lt;- quantile(values(r), 0.05, na.rm = TRUE)\np_high &lt;- quantile(values(r), 0.95, na.rm = TRUE) \n\nr_stretched &lt;- clamp((r - p_low) / (p_high - p_low), lower = 0, upper = 1)\nplot(r_stretched, col = colors)"
  },
  {
    "objectID": "code/MosaicRasters/index.html",
    "href": "code/MosaicRasters/index.html",
    "title": "Mosaic rasters",
    "section": "",
    "text": "library(terra)\n\nterra 1.8.5"
  },
  {
    "objectID": "code/MosaicRasters/index.html#terra",
    "href": "code/MosaicRasters/index.html#terra",
    "title": "Mosaic rasters",
    "section": "",
    "text": "library(terra)\n\nterra 1.8.5"
  },
  {
    "objectID": "code/MosaicRasters/index.html#directory",
    "href": "code/MosaicRasters/index.html#directory",
    "title": "Mosaic rasters",
    "section": "Directory",
    "text": "Directory\n\n# dir and outdir\nfile_dir &lt;- \"/Users/wancher/Documents/weranch/code/tiffs/\"\n#setwd(file_dir)\n\n# read in the rasters \nlist_of_files &lt;- list.files(file_dir, pattern = \"S1A-.*\\\\.tif$\", full.names = TRUE)"
  },
  {
    "objectID": "code/MosaicRasters/index.html#commenting-out-the-for-loop-and-just-work-with-files-from-one-year-for-this-example",
    "href": "code/MosaicRasters/index.html#commenting-out-the-for-loop-and-just-work-with-files-from-one-year-for-this-example",
    "title": "Mosaic rasters",
    "section": "Commenting out the for loop and just work with files from one year for this example",
    "text": "Commenting out the for loop and just work with files from one year for this example\n\n# iterate over a sequence of years and pull out files specific to the year in the sequence\n# mosaics &lt;- list()\n# years &lt;- seq(2019, 2023)\n# years_string &lt;- as.character(years)\n# for (i in seq_along(years_string)) {\n#   \n#   #pull out unique year\n#   year &lt;- years_string[[i]]\n#   files_one_year &lt;- list_of_files[grepl(year, list_of_files)]\n  files_one_year &lt;- list_of_files\n\n  \n  list_of_rasters &lt;- lapply(files_one_year, function(file) {\n    r &lt;- rast(file)\n    r\n  })\n  \n  # get band names for retention\n  #band_names &lt;- names(list_of_rasters[[1]])\n  #flattened_band_names &lt;- unlist(band_names)\n  \n  # turn list in sprc and mosaic\n  coll_of_rasters &lt;- sprc(list_of_rasters)\n  #print(paste0(year, \" start: \", Sys.time()))\n  mosaiced_raster &lt;- merge(coll_of_rasters) \n\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n  #print(paste0(year, \" finish: \", Sys.time()))\n  #names(mosaiced_raster) &lt;- band_names\n  #print(names(mosaiced_raster))\n  #save it\n  # output_filename &lt;- paste0(file_dir, \"s1v-mosaic-\", year, \".tif\")\n  # print(output_filename)\n  # #writeRaster(mosaiced_raster, filename = output_filename, filetype = \"GTiff\", overwrite = TRUE)\n  # mosaics[[i]] &lt;- mosaiced_raster\n  # rm(list_of_rasters, coll_of_rasters, mosaiced_raster)\n  # gc()\n#}"
  },
  {
    "objectID": "code/MosaicRasters/index.html#visualize",
    "href": "code/MosaicRasters/index.html#visualize",
    "title": "Mosaic rasters",
    "section": "Visualize",
    "text": "Visualize\n\n#without mosaicing\nfor (r in list_of_rasters){\n  plot(r)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#after mosaic\nplot(mosaiced_raster, main = \"Summer 2023 C Band Composite\")"
  },
  {
    "objectID": "code.html",
    "href": "code.html",
    "title": "Code Examples",
    "section": "",
    "text": "Plotting prediction accuracy\n\n\n\n\n\n\ntidymodels\n\n\nrandomForest\n\n\nggplot2\n\n\npatchwork\n\n\n\n\n\n\n\n\n\nJul 7, 2025\n\n\nWesley Rancher\n\n\n\n\n\n\n\n\n\n\n\n\nPlotting variable importance\n\n\n\n\n\n\ntidymodels\n\n\npdp\n\n\nvip\n\n\nrandomForest\n\n\n\n\n\n\n\n\n\nJul 7, 2025\n\n\nWesley Rancher\n\n\n\n\n\n\n\n\n\n\n\n\nFitting Random Forests\n\n\n\n\n\n\ntidymodels\n\n\nrandomForest\n\n\ntidyverse\n\n\n\n\n\n\n\n\n\nJul 1, 2025\n\n\nWesley Rancher\n\n\n\n\n\n\n\n\n\n\n\n\nMosaic rasters\n\n\n\n\n\n\nR\n\n\nGEE\n\n\nLandsat\n\n\nimage-processing\n\n\n\n\n\n\n\n\n\nDec 27, 2024\n\n\nWesley Rancher\n\n\n\n\n\n\n\n\n\n\n\n\nContrast stretching\n\n\n\n\n\n\nR\n\n\nLandsat\n\n\nenhancement\n\n\n\n\n\n\n\n\n\nDec 19, 2024\n\n\nWesley Rancher\n\n\n\n\n\n\n\n\n\n\n\n\nRaster manipulation using terra\n\n\n\n\n\n\nR\n\n\nLandsat\n\n\nimage-processing\n\n\n\n\n\n\n\n\n\nDec 19, 2024\n\n\nWesley Rancher\n\n\n\n\n\n\n\n\n\n\n\n\nGraphing raster distribution\n\n\n\n\n\n\nR\n\n\nLandsat\n\n\nggplot\n\n\n\n\n\n\n\n\n\nDec 19, 2024\n\n\nWesley Rancher\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "instructions/Lab4/index.html",
    "href": "instructions/Lab4/index.html",
    "title": "Lab four instructions",
    "section": "",
    "text": "This lab is adapted from the Mapping with Drones class and was originally written by James Lamping and Colin Mast. Here we use a dataset from NOAA and ask slightly different questions about the data.\nLets start by setting up our work space. The things we need to do here are to load the libraries we will use in this analysis and also make sure our working directory is set.\n\n# This section of code below loads necessary packages into our R session.\ninstall.packages(\"pacman\") #when you run code again on the same machine you can comment install.packages lines out\ninstall.packages(\"sf\")\ninstall.packages(\"stars\")\n\n# Install Rtools on Root folder. Edit system environment variables with ming64/bin path. Restart R\n# https://cran.r-project.org/bin/windows/Rtools/rtools44/rtools.html\n# you might need these packages if you cannot plot your point cloud\n#https://www.xquartz.org/ #install this and unzip if running on macOS\n#install.packages(\"rgl\")\n#install.packages(\"stars\", type = \"source\") #an alternative attempt at line 4 of this chunk\n\npacman::p_load(\"lidR\", \"tidyverse\", \"terra\", \"tidyterra\", \"future\", 'RCSF', 'gstat') \nlibrary(sf)\nlibrary(stars)\n\n# Now we need to set the working directory. This is the filepath where we are going to be working from.\nsetwd(\"R:/Geog485_585/Class_Data/Lab4_1/\")\nsetwd(\"/Users/wancher/Documents/rs_485/input_data/\")\n\nFirst, lets bring in some lidar data and take a look at it.\n\n#Here is the source for the data used in this lab\n#https://portal.opentopography.org/lidarDataset?opentopoID=OTLAS.102010.26910.1\n\n# There are two main file types that you will see with lidar data, LAS and LAZ. The LAZ file type is highly compressed, saving a lot of room for storage and transfer. Most processing software can read LAZ files, however they default to LAS when exporting. Be careful about storage space when dealing with lidar data.\n# read in an individual LAZ file\nlas &lt;- readLAS(\"ot_000119.laz\")\n# lets take a peak at what that looks like\nplot(las)\n\n# Some lidar data also has RGB data included. If so this is how you would visualize it in color.\n#plot(las, color = \"RGB\") \n\nlas # run this code and it will give you a basic summary of the object\n\nSECTION TURN IN\n\nTake a screen shot of your point cloud\nWhat is the difference between LAS and LAZ?\nWhat coordinate reference system is your data in?\nWhat is your point density?\nHow much area does your data cover?\n\n\nWe are going to chunk our data so we can work with smaller files for subsequent steps.\n\n# bring in the large lidar file as a LAS Catalog\nctg &lt;- readLAScatalog(\"ot_000119.laz\")\nplot(ctg, chunk = TRUE)\n\n# Create a new set of 200 x 200 m. laz files with a 10 meter buffer.\nopt_chunk_buffer(ctg) &lt;- 10\nopt_chunk_size(ctg) &lt;- 200\nplot(ctg, chunk = TRUE)\nopt_laz_compression(ctg) &lt;- TRUE # this tells it to be a .laz file instead of a .las file\n\n#set an output folder path (as is, this will write to wherever you setwd)\nopt_output_files(ctg) &lt;- \"retile_{XLEFT}_{YBOTTOM}\" # this sets the folder location and name with the coordinates of the chunk.\n\n# preview the chunk pattern and create new tiles\nplot(ctg, chunk = TRUE)\nplan(multisession, workers = availableCores() - 1) # create a parallel session. This lets you process more than one at a time\nnewctg = catalog_retile(ctg)\nplot(newctg)\n\nPoint classification\nOne of the most important steps in processing lidar is classifying points to different categories. A lot of freely available aerial lidar already comes classified as part of a completed validated dataset. However, if you are the one producing the lidar from a drone you will need to classify the point cloud yourself. There are many standards when it comes to lidar data and most are controlled by ASPRS. To read more about the classification standards of ASPERS visit the link below. Table 3 contains the standard classification values and meanings set by ASPERS. We will just be focusing on classifying ground points in this lab.\nhttps://www.asprs.org/wp-content/uploads/2010/12/LAS_Specification.pdf\n\n# lets plot our data and see if these points are already classified.\nplot(las, color = \"Classification\")\n\n# It likely is, and in this case you will see white points for unclass (0) and blue points for points classified as ground (2). Lets bring the point cloud back in as if there are no ground points classified with the filter funtions in lidR.\n\n#read in one of the tiles that you created\nlas &lt;- readLAS(\"retile_722200_4940600.laz\", filter = \"-change_classification_from_to 2 0\")\nplot(las, color = \"Classification\")\n\n# Now we are going to use the ground classification algorithm to classify points as either ground or not. There are a few different methods for this. For details on other methods please look here: https://r-lidar.github.io/lidRbook/gnd.html\nlas_class &lt;- classify_ground(las, algorithm = pmf(ws = 5, th = 3))\n\n# How does it look? Zoom in move around. Does it look like it performed well? If not, maybe try another classification method from the link above.\nplot(las_class, color = \"Classification\", size = 3, bg = \"white\")\n\n# Another way to see how well this worked is by plotting a cross section.\nplot_crossection &lt;- function(las,\n                             p1 = c(min(las@data$X), mean(las@data$Y)),\n                             p2 = c(max(las@data$X), mean(las@data$Y)),\n                             width = 4, colour_by = NULL)\n{\n  colour_by &lt;- enquo(colour_by)\n  data_clip &lt;- clip_transect(las, p1, p2, width)\n  p &lt;- ggplot(data_clip@data, aes(X,Z)) + geom_point(size = .5) + coord_equal() + theme_minimal()\n  \n  if (!is.null(colour_by))\n    p &lt;- p + aes(color = !!colour_by) + labs(color = \"\")\n  \n  return(p)\n}\n\nplot_crossection(las_class, colour_by = factor(Classification))\n\nSECTION TURN IN\n\nTake a screen shot of the cross section you created with the pmf function.\nHow well did it perform?\nDid you have to use a different classification? If so, what did you end up using?\nWhat do you see in your classified point cloud?\n\n\nCreating a digital surface model (DSM)\nLets start off by making a DSM. If you remember from lecture a DSM includes all ground and vegetaion points. Its like draping a sheet across the surface of everything that is there.\n\ndsm &lt;- rasterize_canopy(las_class, res = 1, p2r(na.fill = tin()))\ncol &lt;- height.colors(25) # create a color profile\nplot(dsm, col = col, main = \"Digital Surface Model\")\n\n#summary stats\nsummary(dsm) \nhist(dsm)#repeat this for dtm and chm\n\nCreating a digital terrain model (DTM)\nOne of the neatest things about lidar data is its ability to model what lies beneath the canopy. Where are old logging roads? Are there artifacts beneath the vegetation? What is the actual elevation of the land? Lets only look at the ground points and make another surface model of the terrain (DTM).\n\n#this one could take awhile\ndtm &lt;- rasterize_terrain(las_class, algorithm = kriging(k = 40))\nplot(dtm, main = \"Digital Terrain Model\") \n\n# that doesnt look like much... lets make a hillsahde\ndtm_prod &lt;- terrain(dtm, v = c(\"slope\", \"aspect\"), unit = \"radians\")\ndtm_hillshade &lt;- shade(slope = dtm_prod$slope, aspect = dtm_prod$aspect)\nplot(dtm_hillshade, col =gray(0:30/30), legend = FALSE, main = \"DTM Hillshade\")\n\nCreating a canopy height model (CHM)\nTo look at the height of only the vegetation we need to subtract the height of the ground out of our data. Looking at the DSM you see individual trees, but the height data is a combination of both the ground height and the vegetation height. Lets get rid of the ground and look at the trees!\n\nlas_norm &lt;- normalize_height(las_class, algorithm = tin())\nplot(las_norm, color = \"Classification\") # notice how the terrain is now completely flat\n\n# now that we have no more terrain elevation. Lets make another surface model. This will be our CHM.\nchm &lt;- rasterize_canopy(las_norm, res = 1, pitfree(thresholds = c(0, 10, 20), max_edge = c(0, 1.5)))\nplot(chm, col = col, main = \"Canopy Height Model\")#what are the units\n\nSECTION TURN IN\n\nScreenshots of all terrain models and histograms.\nReport the average values of each model. You can copy summary(dsm) for dtm and chm models.\n\n\nIndividual tree detection\nNow that we have the lidar processed and our terrain models generated, lets do something a bit more advanced. From the terrain data and the unclassified vegetation data there are methods of detecting and modeling every tree on the landscape. This can be useful in so many different ways! It can tell us the density of trees on the landscape, the height distrubution, and even estimate how much biomass there is in the living trees. For this lab we will locate each tree and create spatial data of the canopy area of each tree.\nThere are many different ways of going about this. For this I chose the fastest, but it might not be the most accurate for this environment. Feel free to try other methods as described here: https://r-lidar.github.io/lidRbook/itd-its.html\n\n# locate all the tops of the trees. This does this by looking at a local area maximum height within a set radius.\nttops &lt;- locate_trees(las_norm, lmf(ws = 5))\n\n# plot the tree tops on top of the CHM\nplot(chm, col = height.colors(50))\nplot(sf::st_geometry(ttops), add = TRUE, pch = 3)\n\n#Lets see what that looks like on top of the normalized point cloud.\nx &lt;- plot(las_norm, bg = \"white\", size = 4)\nadd_treetops3d(x, ttops)\n## Do you think it is oversegmenting trees (as in there are more than one \"tree top\" per tree)? If so, change the window size (ws) to a larger one and see how that performs.\n\n# Now lets segment the point cloud. To do this we will use the CHM and the tree tops to identify canopies. Then we will segment the point cloud to have individual trees identified.\nlas_seg &lt;- segment_trees(las_norm, dalponte2016(chm, ttops)) # segment point cloud\nplot(las_seg, bg = \"white\", size = 4, color = \"treeID\") # visualize trees\n\n# you can now look at individual trees!\ntree110 &lt;- filter_poi(las_seg, treeID == 110)\nplot(tree110, size = 8, bg = \"white\")\n\n# from the segmented lidar you can now easily make spatial data that has information about each tree. This is useful in arcpro or QGIS and is the product you will need to make basic figures and maps about the status of those trees.\ncrowns &lt;- crown_metrics(las_seg, func = .stdmetrics, geom = \"convex\")\nplot(crowns[\"zq95\"], main = \"95th percentile of tree height (feet)\")\nnames(crowns) # look at all the data you now have of each tree\n\nExporting data\nAll of this can be easily exported for use in other geospatial programs. Lets do that now!\n\n# rasters\nwriteRaster(dsm, \"data/output/lidar_dsm.tif\", overwrite = TRUE)\nwriteRaster(dtm, \"data/output/lidar_dtm.tif\", overwrite = TRUE)\nwriteRaster(chm, \"data/output/lidar_chm.tif\", overwrite = TRUE)\nwriteRaster(dtm_hillshade, \"data/output/lidar_hillshade.tif\", overwrite = TRUE)\n\n# vectors\nwriteVector(vect(crowns), \"data/output/Crowns/lidar_tree_crowns.shp\")\n\nSECTION TURN IN\n\nAdd your output rasters to a QGIS environment and change symbology. You can add these screenshots to your write up if you want.\n\n\nAdditional processing with lasCatalog. No submission required here but worth knowing how to process larger datasets\nAt the very beginning of this exercise you created a catalog from the large lidar dataset to create smaller chunks that are much more manageable to analyze. In the same way your created these chunks you can analyze these as a whole unit to create complete output products for a whole area. There are many functions that work with the lasCatalog engine in lidR, including terrain modeling, tree segmentation, and classification. Below we are going to just create a DTM on the whole dataset. Remember that the dataset we used for this lab already had ground points classified, so lets just go ahead and run the analysis.\n\nctg_dtm &lt;- rasterize_terrain(ctg, algorithm = tin()) # calling a catalog into a function runs that function through the lascatalog engine\nplot(ctg_dtm, main = \"Digital Terrain Model\") \n\n# that doesnt look like much... lets make a hillsahde\nctg_dtm_prod &lt;- terrain(ctg_dtm, v = c(\"slope\", \"aspect\"), unit = \"radians\")\nctg_dtm_hillshade &lt;- shade(slope = ctg_dtm_prod$slope, aspect = ctg_dtm_prod$aspect)\nplot(ctg_dtm_hillshade, col =gray(0:30/30), legend = FALSE, main = \"DTM Hillshade\")\n\n# export DTM and hillshade\nwriteRaster(ctg_dtm, \"data/output/ctg_DTM.tif\", overwrite = TRUE)\nwriteRaster(ctg_dtm_hillshade, \"data/output/ctg_Hillshade.tif\", overwrite = TRUE)"
  },
  {
    "objectID": "instructions/Lab2/index.html",
    "href": "instructions/Lab2/index.html",
    "title": "Lab two instructions",
    "section": "",
    "text": "Summary\n\nThe objective of this lab is to enhance satellite imagery using a few different techniques. This lab assumes no prior coding experience and is commented thoroughly to explain what each line is doing. After setting things up it should run fairly smoothly but please ask if you need help!! I’m not trying to throw you to the wolves but learning R (among other tools), is an extremely useful skill in GIScience.\nThis script is available in the R drive as “enhance.qmd”. Copy it to your folder.\nAs for data, you have been provided images in the class R drive. Copy them to your project folder where you prefer to store data.\nWe will be working with Landsat 8/9 (Level 1 and 2) and Sentinel 2A imagery from 2019-2024. You should look up these satellites and sensors to clarify what the levels indicate and what information or bands might be present in the images.\nIn brief, you will start by getting acquianted with R and RStudio and figuring out how to read in data. You will then move to displaying your data and exploring summary statistics. This will give you a lay of the land, and then you can go on to enhancement techniques. These instructions will outline how to do this for a subset of the data (you will just need to replicate the steps for ALL of your data). The last step of this lab is to compare across datasets and across time and infer based on what you create (quantitatively and qualitatively).\n\n\n\nSetting up R\n\nTo run a line of code move your cursor to the line and press ctrl+Enter. To run a chunk of code press the green button at the top right of the chunk. If a a line starts with a #, it is a comment but it can also be used to prevent a line from running. See how I comment out install packages on line 31 since I have already installed this package on my computer.\n\nInstall terra and other packages. Terra is the main library that will let us work with spatial data\n\n#install.packages(\"terra\")\n#install.packages(\"RStoolbox\")\n#install.packages(\"ggplot2\")\n#install.packages(\"dplyr\")\n#install.packages(\"ggspatial\")\n#install.packages(\"tmap\")\n\nlibrary(terra)\nlibrary(RStoolbox)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggspatial)\nlibrary(tmap)\n\nPaste this in the terminal to create an R project. This will make it easy to navigate around our folders in RStudio.\n\n#replace with the path to your lab 2 folder\n#cd /path/to/files/\n#touch lab-one.Rproj\n\nLet’s figure out where we are and get where we need to be\n\n#this prints the working directory\ngetwd()\n\n#this sets the working directory\n#setwd(\"/Users/wancher/Documents/rs_485/input_data/\")\n#setwd(\"D:/RemoteSensingLabs/input_data/\")\n\n\n\nReading in data\nRead in a single image\n\n# the arrow is the same as =\n# replace with your file name\ndir &lt;- \"/Users/wancher/Documents/rs_485/input_data/\"\nr &lt;- rast(paste0(dir,\"landsat_panchro_2023.tif\"))\nr\n\nThis is how you can plot something\n\nplot(r)\n\nPrint summary statistics and plot a histogram\n\nsummary(r)\nhist(r)\n\nThose are the basics of how to read an inspect an image. You can read in your other files the same way. Something like this…\n\n#sentinel_b2 &lt;- \"landsat8_2024_rawbands.tif\"\n#sentinel_b3 &lt;- \"sentinel_2019_rawbands.tif\"\n\nOR\nWe can read in all of the tiff files from our current working folder and store them in a list\n\ndir &lt;- \"/Users/wancher/Documents/rs_485/input_data\"\nlist_of_files &lt;- list.files(dir, pattern=\"*.tif\", full.names = TRUE)\nlist_of_files\n\nThis is just a list of the file paths. So let’s convert it to list of rasters or SpatRasters as terra puts it\n\n#lapply means list apply. So perform terra's rast function on a list of items\nlist_of_rasters &lt;- lapply(list_of_files, rast)\n\n#sometimes the names don't transfer properly so you can change them if needed\nnames(list_of_rasters) &lt;- list_of_files\n\n\n\nFor loops\nWe can write a for loop to do things in iteration. Let’s say we want to plot each image in our list of rasters.\n\n#for each each raster in the sequence, do x thing...\nfor (i in seq_along(list_of_rasters)){\n    one_image &lt;- list_of_rasters[[i]]\n    \n    #store the name of the image\n    filename &lt;- basename(sources(one_image))\n    plot(one_image, main = paste0(filename))\n    rm(one_image)\n}\n#this might take a second\n\n\n\nDisplaying data iteratively\nNow… let’s plot in true color using the plotrgb function\n\n#just one image and band\nplot(list_of_rasters[[1]]) #here I am just reaching into the list of rasters and grabbing the 2nd item and Band 3\nnames(list_of_rasters[[1]])\n\n#just one image in true color\nplotRGB(list_of_rasters[[7]], r=4, g=3, b=2, stretch = \"lin\")\n\nLet’s do the same thing using a for loop over the entire list of rasters. You can decide if you want to use something like a for loop for the later enhancement techniques or if you would prefer to write things out line by line.\n\n#iterate \nfor (raster in list_of_rasters){\n  #if there is more than one band in the raster then...\n  if (nlyr(raster) &gt; 1){\n      filename &lt;- varnames(raster)\n      \n      plotRGB(raster, r=7, g=2, b=4, \n              stretch = \"lin\",\n              smooth = TRUE,\n              main = paste0(\"true color: \", filename))\n      \n      #otherwise if the image only has one band\n  } else {\n    filename2 &lt;- varnames(raster)\n    plot(raster, main = paste0(\"b8: \", filename2), stretch = \"lin\")\n  }\n}\n\nSECTION TURN IN\nQuestion 1: What bands are needed to make a true color image for Landsat 8 and 9?\nQuestion 2: Did the Sentinel images plot in true color? What bands are needed for true color with Sentinel 2A?\nQuestion 3: Is the “plotRGB” function in the above chunk the same as the Build Virtual Raster tool in QGIS? yes/no/why?\nQuestion 4: What are different types of stretch methods within the PlotRGB function?\nScreenshots: Answers to questions above alongside 3 screenshots. Select one year between 2019 and 2024 and submit a screenshot of the corresponding images in that year. (Should be a landsat true color, sentinel true color, and landsat panchromatic). If your images did not display in true color, you should tweak the arguments in the plotRGB function!\n\n\nPansharpening\n\n#print the spatial resolution\nres(list_of_rasters[[1]])\nres(list_of_rasters[[7]])\nres(list_of_rasters[[14]])\n\n#you'll notice that there is a difference in spatial resolution between the landsat raw bands, landsat panchromatic, and sentinel. Since the goal here is to compare across Landsat and Sentinel we will downsample our landsat rawbands to the higher resolution of the panchromatic band (from 30m down to 15m).\n\n#as an example\npanchro_test &lt;- list_of_rasters[[1]]\nlandsat_rawbands_test &lt;- list_of_rasters[[7]]\n\n#be sure to specify the correct bands\nlandsat_rawbands_sharpened &lt;- panSharpen(landsat_rawbands_test, panchro_test, \n                                          r = 5, g = 4, b = 3, method = \"brovey\")\n\nSECTION TURN IN\nQuestion 1: What do you think of the result? What happens if you change the method?\nQuestion 2: What is the spatial resolution of the panchromatic data compared to the raw bands of Landsat? What about the spatial resolution of Sentinel?\nQuestion 3: What units of resolution are your images in?\nQuestion 4: Answers to questions and pansharpen one of your Landsat images and submit a screenshot of the result, with a figure caption. I’ll let you decide if you would like to pansharpen all of your Landsat images.\n\n\nConstrast stretching\n\nJust as you would photoshop a photo you to enhance the quality or color for sharing on social media or with friends and family, we can do the same thing in remote sensing.\nSince we know that images are just numbers, we can think of this process as stretching the image values towards the extremes of the data range.\n\nRename the bands so operations only need cast once.\n\n#rename the bands so we can write a universal equation\nband_names_landsat &lt;- c(\"aerosol\", \"blue\", \"green\", \"red\", \"nir\", \"swir1\", \"swir2\")\nband_names_sentinel &lt;- c(\"blue\", \"green\", \"red\", \"rededge1\", \"rededge2\", \"rededge3\", \"nir\", \"rededge4\", \"swir1\", \"swir2\")\n\nrename_bands &lt;- function(raster) {\n  if (\"SR_B1\" %in% names(raster)) {\n    names(raster) &lt;- band_names_landsat\n    return(raster)\n  } else if (\"B2\" %in% names(raster)) {\n    names(raster) &lt;- band_names_sentinel\n    return(raster)\n  } else {\n    return(NULL)\n  }\n}\n\nlist_of_rasters_renamed &lt;- lapply(list_of_rasters, rename_bands)\nlist_of_rasters_renamed &lt;- list_of_rasters_renamed[-c(1:6)]#rm the panchro images\n\nStretch one image\n\ntest_image &lt;- list_of_rasters_renamed[[12]]\nhist(test_image$red)#red for example\nplot(test_image$red)\n\n#the 5th and 80th percentiles of the raster (values which 5% and 80% of the raster fall under)\np_low &lt;- quantile(values(test_image$red), 0.05, na.rm = TRUE)\np_high &lt;- quantile(values(test_image$red), 0.80, na.rm = TRUE) \n\n#limit the range of the raster to these high and low values and change the scale to range from 0 to 1\nr_stretched &lt;- clamp((test_image$red - p_low) / (p_high - p_low), lower = 0, upper = 1)\nplot(r_stretched$red)\nhist(r_stretched$red)\n\nSECTION TURN IN\nQuestions: What are your thoughts about the contrast stretch result? Did you try changing the percentile values?\nContrast stretch each band in each image\n\ncontrast_stretch &lt;- function(raster_band){\n  p_low &lt;- quantile(values(raster_band), 0.05, na.rm = TRUE)\n  p_high &lt;- quantile(values(raster_band), 0.90, na.rm = TRUE) \n  stretched_band &lt;- clamp((raster_band - p_low) / (p_high - p_low), \n                          lower = 0, upper = 1)\n  return(stretched_band)\n}\n\n#function to apply the stretch to each band and each raster\napply_stretch &lt;- function(raster) {\n  band_names &lt;- names(raster)\n  \n  #apply stretch to each band\n  stretched_bands &lt;- lapply(band_names, function(band_name) {\n    band &lt;- raster[[band_name]]\n    contrast_stretch(band)\n  })\n  #combine stretched bands into one raster\n  stretched_raster &lt;- c(stretched_bands)\n  names(stretched_raster) &lt;- band_names#retain bandnames\n  return(stretched_raster)\n}\n\nlist_of_stretched_rasters &lt;- lapply(list_of_rasters_renamed, apply_stretch)\n\n\n\nCalculating vegetation indices\n\nYou can now calculate vegetation or other indices on your stretched images.\nSay you would like to look at vegetation health around Mount St Helens. You can look up things in google like “how do I compute NDVI for Landsat?” (assuming you have heard about NDVI), or “what is a good index to use when monitoring vegetation with Landsat?” What you will find is that remote sensing scientists have developed equations for answering these types of questions and it is pretty straightforward to apply if you have your data and software ready.\nIn R, we can using simple arithmetic operations to do this. For example, to compute the Normalized Differenced Vegetation Index (NDVI), the equation is like so:\n\nNDVI = NIR-RED/NIR+RED\nLet’s grab an image and try it:\n\n#dollar sign indexing is what this is called \n#i like to follow good ole PEMDAS pretty closely when I do band math just to be cautious\ntest_ndvi &lt;- (r_stretched$B8- r_stretched$B4) / \n             (r_stretched$B8 + r_stretched$B4)\nsummary(test_ndvi)\n\nhist(test_ndvi)\nplot(test_ndvi)\n\nVisualizing a different way\n\n#different color palette\nndvi_palette &lt;- colorRampPalette(c(\"#FFFF00\", \"#FF0000\", \"#FF00FF\", \"#0000FF\", \"#639200\"))(100)\n\n#plot\nplot(test_ndvi, col = ndvi_palette, main = \"ndvi sentinel\")\n\n#compare this with true color\nplotRGB(r_stretched, r=3, g=2, b=1, stretch = \"lin\")\n\n#save and take it to qgis\n#writeRaster(test_ndvi, \"/Users/wancher/Documents/rs_485/output_data/ndvi_sentinel_2022.tif\")\n\nSECTION TURN IN\nScreenshots: Take a screenshot of the test NDVI you produced in the default color palette, and then define your own color palette (line 317) and submit another screenshot. Mention how this either helped or did not help your interpretation of the data.\nLet’s write a function to compute ndvi for each image and then apply it to the list of rasters.\n\n#write functions to calculate ndvi\ncalculate_ndvi &lt;- function(raster){\n  ndvi &lt;- (raster$nir - raster$red) / (raster$nir + raster$red)\n  names(ndvi) &lt;- \"ndvi\"\n  return(ndvi)\n}\nlist_of_ndvis &lt;- lapply(list_of_stretched_rasters, calculate_ndvi)\n\n\n\nComparison\n\nYou are now going to create graphs to show your indices through time.\n\nHere is an example:\n\n#example of how to convert a raster to a dataframe\ndf &lt;- as.data.frame(r) #not going to use it but this is the basic function you need (line 349)\n\n#function to convert rasters to dataframes\nraster_to_dataframe &lt;- function(raster){\n  source &lt;- strsplit(varnames(raster), \"_\")[[1]][1] #split the filename by recognizing the underscore seperator and grab the first element\n  year &lt;- strsplit(varnames(raster), \"_\")[[1]][3]#third element (which is year if you look at the filename)\n  \n  #average and variance\n  df &lt;- as.data.frame(raster, xy = TRUE) %&gt;%\n    summarise(Avg_NDVI = mean(ndvi, na.rm = TRUE),\n              SD_NDVI = sd(ndvi, na.rm = TRUE))\n    \n  df$source &lt;- source #add source column\n  df$year &lt;- as.numeric(year) #add year column\n  \n  return(df)\n}\n\n#convert the list of NDVIs to a list of dataframes so we can graph\nlist_of_dfs &lt;- lapply(list_of_ndvis, raster_to_dataframe)\ncombined_df &lt;- do.call(rbind, list_of_dfs) #rowbind the dataframes into one dataframe\n\n#if you would like to work in excel!\n#write.csv(combined_df, /path/to/output/folder/*.csv, row.names = FALSE)\n\nPlot\n\n#plotting through time using ggplot library\nggplot(combined_df, aes(x = year, y = Avg_NDVI, color = source)) +\n  geom_smooth(size = 2) + \n  geom_point(size = 3) + #add points\n  #geom_errorbar(aes(ymin = Avg_NDVI - SD_NDVI, ymax = Avg_NDVI + SD_NDVI), width = 0.2) + \n  labs(title = \"Normalized Difference Vegetation Index in AOI\",\n       x = \"Year\",\n       y = \"Average NDVI\",\n       color = \"Satellite\") +\n  theme_minimal()\n\nSECTION TURN IN\nQuestions: Your average NDVI value is an average of what exactly? What would you need to do if you wanted the average NDVI value in a particular spot in your image?\nScreenshots: Screenshot or figure with caption showing NDVI through time. Calculate at least 2 additional indices and make similar plots.\n\n\nDifference maps\n\nFor your last step you need to calculate take the difference between 2024 and 2019 for each index and satellite.\n\nFor example: NDVI_Landsat_2024.tif - NDVI_Landsat_2019.tif\nHere is how I would do it for the NDVI Image. Feel free to use the writeRaster function to export your ndvi images and make a layout in ArcGIS or QGIS if you would be more comfortable there. The ggplot layout is acceptable though!\n\nndvi_diff &lt;- list_of_ndvis[[12]] - list_of_ndvis[[7]]\n\n#using tmap\nndvi_palette &lt;- c(\"#a50026\", \"#d73027\", \"#f46d43\", \"#fdae61\", \n                  \"#66bd63\", \"#006837\")\ntm_shape(ndvi_diff) +\n  tm_raster(midpoint = NA, style = \"pretty\", palette = ndvi_palette, title = \"Range\") +\n  tm_layout(title = \"Sentinel NDVI Difference (2024 - 2019)\",\n            legend.position = c(\"right\", \"bottom\"),\n            legend.bg.color = \"white\",  #legend background\n            legend.frame = TRUE,  #legend border\n            legend.text.size = 1.2, \n            legend.title.size = 1.4) +\n  tm_compass(size = 2, position = c(\"right\", \"top\")) +  #north arrow\n  tm_scale_bar(text.size = 1, position = c(\"left\", \"bottom\"))  #scale bar\n\nSECTION TURN IN\nScreenshots: Maps of index change between 2019 and 2024 for each index. Include a north arrow and scale bar. Use intuitive color palettes. Describe what we are looking at. As always toggle it on and off with true color images to guide your interpretation.\nFINAL SUBMISSION:\nPlease submit…\n\nA PDF write up answering the questions throughout with your screenshots attached\n\n#OR\n\nYou can submit this .QMD document rendered (see top of the script), with “eval=TRUE”. This will convert the document to an HTML and will run your code. If you select this method you can just type your responses directly beneath the questions. Please submit both the HTML and QMD if you go with this option. You may get an error which is sort of difficult to debug. So I would suggest writing up a PDF to be safe but know that this option exists."
  },
  {
    "objectID": "teaching.html",
    "href": "teaching.html",
    "title": "Lab exercises",
    "section": "",
    "text": "We will work through various standard remote sensing techniques in these labs. However, we will be focusing on one area of interest: Mount St Helens. This will enable us to tell a story using remote sensing methods while fine tuning our skills.\nLabs might be updated up until their open date! Feel free to add to this collaborative Spotify playlist so we have some tunes while we work.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab one instructions\n\n\n\n\n\n\nQGIS\n\n\ncomposite-bands\n\n\nEarthExplorer\n\n\n\n\n\n\n\n\n\nDec 19, 2024\n\n\nWesley Rancher\n\n\n\n\n\n\n\n\n\n\n\n\nLab three instructions\n\n\n\n\n\n\nQGIS\n\n\nclassification\n\n\nk-means-clustering\n\n\n\n\n\n\n\n\n\nDec 19, 2024\n\n\nWesley Rancher\n\n\n\n\n\n\n\n\n\n\n\n\nLab four instructions\n\n\n\n\n\n\nR\n\n\nQGIS\n\n\nLiDAR\n\n\n\n\n\n\n\n\n\nFeb 18, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nLab four.2 instructions\n\n\n\n\n\n\nAgisoft Metashape\n\n\nPhotogrammetry\n\n\n\n\n\n\n\n\n\nFeb 18, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nLab two instructions\n\n\n\n\n\n\nR\n\n\nimage-enhancement\n\n\n\n\n\n\n\n\n\nJan 5, 2024\n\n\nWesley Rancher\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "instructions/Lab1/index.html",
    "href": "instructions/Lab1/index.html",
    "title": "Lab one instructions",
    "section": "",
    "text": "An Image is Worth at Least a Thousand Words\n\nSummary\nA useful tip when working with remote sensing data is to consider beginning your workflow by visualizing your data in true color. This can serve as reference prior to processing so that you can toggle the changes you make on and off and make semi-informed interpretations, at least at the beginning. There is SO much remote sensing data that is freely available but the go-to data source is often Landsat because of its historical record. It is also relatively easy to download Landsat imagery with different levels of processing (for example, surface reflectance vs top-of-atmosphere reflectance products vs analysis ready data), which can take a lot of steps out of the scientific process for us but means we have less influence how the processing is applied. Nonetheless the surface reflectance product from Landsat has been used in many studies, here is a good review paper.\nAs for data, I’ll provide USGS’s EarthExplorer for your reference, which is a simple, web-based archive of satellite and aerial imagery and indices from various sources. You will need to create an account to download data. You are not limited to EarthExplorer, there are other sources like The National Map, ArcGIS online, and Google Earth Engine (GEE). We will introduce (GEE) in future labs when we need more data.\nInside EarthExplorer, you can filter your data search spatially, temporally, and by cloud cover. Try to get logged on, drop a pin on or near Mount St Helens and define a date range and cloud cover percentage (lower cloud cover is great). [Check out this demo] for steps to download and visualize!\n\n\n\nFigure 1: True Color Composite of Landsat 8 (RED, GREEN, BLUE)\n\n\n\n\nSoftware and tools\nYou will want to get familiar with the GIS software and your file structure if you are not already. I typically start a file structure like this:\nrs_485/\n─ lab_one/\n├── input_data/ &lt;– raw images, shapefiles\n├── output_data/ &lt;– processed imagery, CSVs\n├── scripts/ &lt;– useful in future labs\n├── venv/ &lt;– useful in future labs\n└── writing/\nNote that data in future labs may be uploaded to the R drive.\nThis lab relies on QGIS which is an open-source platform that we will use for most of our visualization and image manipulation. However, examples of different approaches techniques using alternative software R, GEE and Python are provided in future labs.\n\n\n\nWhat you are going to submit\n\nA PDF documenting the steps you took to create a true color and or false image composites from raw satellite imagery. This can be as detailed as you want, but you must obtain imagery from 5 distinct satellite or aerial sources, display and manipulate each image in QGIS (documenting your methods).\nScreenshot of each image with brief description\nReview advantages and disadvantages and which datasets might be useful as we continue to study the region\nA brief reflection on the types of imagery you would use for specific studies\n\n\n\n\nFigure 2: False Color Composite of Landsat 8 (SWIR2, NIR, RED)\n\n\n\n\nCheck out this demo\nhttps://youtu.be/u-FCX4RjsxM"
  },
  {
    "objectID": "instructions/Lab3/index.html",
    "href": "instructions/Lab3/index.html",
    "title": "Lab three instructions",
    "section": "",
    "text": "We will use QGIS for this lab and will install the SAGA NextGen plugin and Dzetsaka.\n\nInside QGIS select the plugins tab at the top.\nManage and install plugins\nMake sure you are on the “All” tab and search for SAGA. It is a blue logo: “Processing Saga NextGen Provider. Select it and install.\nNow search for dzetsaka and install\nYou can close the pop-up\n\nPlease let me know if you have trouble getting these tools installed!\nBe sure to start a QGIS project and save it. You will not need to install or load the tool your next time working on the machine. You will need to install it if you work on a new computer next time.\n\n\n\nYou will download Landsat imagery on EarthExplorer of the Mt St Helens area, before and after the 1980 eruption to answer a brief research question of something that interests you (for example: how long did it take for vegetation recovery after the eruption?). The research question will guide the image dates and number of images you download. It’s been almost 45 years, so using Landsat you should be able and ask a pretty interesting question about this. If visible bands are not available you can download any raw bands that are available.\nYou will work image by image, and your task is to classify pixels in the image to match a classification schema of interest (i.e., landcover or forest type).\nYou will be using your image interpretation skills to generate training data\n\nAt this point you can navigate to EarthExplorer, download your Landsat images and then read on.\n\nThis lab will be divided into three parts.\nPart one: Unsupervised classification.\n\nThe tool you are going to run in QGIS will basically group pixels that have similar spectral characteristics to classes or clusters without any additional information from the user (you).\nFor example: pixels that have really high NIR values could be grouped as one cluster because maybe these pixels have vegetation in them.\n\nPart two: Supervised classification.\n\nThe tool will take additional information (training data) and then it will look at the spectral characteristics of each pixel and group into classes accordingly. You are going to be the source of this training data (more on this below).\n\nPart three: Change detection\n\nYou will run the supervised classification algorithms for your remaining image dates.\n\n\n\n\nFirst, consider: what is it you would like to investigate about the landscape? How will you set up your classification schema? Create a classification key with class, value, and color as columns for reference. You have to freedom over what this looks like and it is purely for reference. Use excel, notepad, or word create one. Here is mine:\n\n\n\nClass\nValue\nColor\n\n\n\n\nHealthy Forest\n1\nGreen\n\n\nUrban\n2\nGray\n\n\nWater\n3\nBlue\n\n\nGrass\n4\nYellow\n\n\nUnhealthy Forest\n5\nBrown\n\n\n\n\n\n\nPrepare the Data:\n\nLoad layers into QGIS. Just use one image date to start\nCreate a true color composite or false color composite for reference using the Build Virtual Raster Tool.\n\nRaster tab (top of the screen)\nMiscellaneous\nBuild Virtual Raster\nSelect input layers\nSet Resolution to highest\nPlace each input file in separate band\nRUN\n\nRemember that the virtual output you created does not automatically save.\n\nRight-click the virtual layer\nExport\nSave in the output data as a tif\nBe specific with how you name (i.e., FCC_1979.tif)\n\n\nDefine Area of Interest:\n\nCreate a polygon shapefile around Mt. St. Helens to use as a clipping mask.\nLayer tab (top of the screen)\nCreate layer\nNew shapefile layer\nFilename is up to you\nGeometry type: polygon\nRUN\nRight-click the shapefile in your layers tab\nSelect “Toggle editing”\nAdd polygon (see screenshot) then Click somewhere on the screen to begin drawing and complete the polygon by right-clicking\nRight-click and select toggle editing again to turn it off\n\n\nClip Raster by Mask:\n\nClip your images to the shapefile. The shapefile will act as a cookie cutter.\nSearch the processing toolbox for “Clip raster by mask layer”. If you don’t see the toolbox on the right side of QGIS press CTRL + ALT + T.\nInput layer: Landsat raw band raster (you will have to do this for each raw band raster instead of composites because the classification tool will not work for a composite image).\nMask layer: The shapefile you created\nClipped mask: Save this in your output data as a TIF (i.e., Landsat_1979_B5_CLIPPED.tif)\nRUN\nRinse and repeat for the other bands\n\nK-Means Clustering:\n\nSearch for K-means clustering for grids in your toolbox window\nInput the clipped rasters from above. Set the Number of Clusters based on your classification key (for example, 5 clusters for 5 land cover classes).\nAdjust the Iterations to control how many times the algorithm tries to classify pixels (usually around 10-20 iterations). More on the tool\nRun the tool. See the parameters I used:\n\n\nClassify the Output:\n\nAfter running the tool, the output will be a classified raster. #WOW\n\nDo a quick export of the clusters layer in your layers pane and save it as a tif. It won’t save if you reload QGIS because it is just a temporary file at the moment.\nOnce you save it, load it into your layers and change the symbology to apply a random color palette or directly adjust the colors according to your KEY!\n\nRight-click the output clusters layer\nProperties\nSymbology\nChange the render type to paletted/ unique values\nPress classify\nPress apply\nChange the colors to match your key (read below)\n\nNow, use a true color or false color composite as a reference (toggle your layer on and off) to visually inspect the output and match it with the classification key. Take a screenshot of your classified output after setting the colors as close to your key as possible. Do this to the best of your ability.\n\n\nSee if your output looks any better than this but remember this was unsupervised:\n\n\n\n\n\n\n\n\n\nCollect Training Data (take your pick of option 1 or option 2):\n\nOption 1: You can search the toolbox for a tool called random points in extent\n\n10 points minimum per class (so 50 points if you are going for 5 classes)\ninput extent: calculate from layer and use the shapefile from step 2 in the unsupervised classification section.\nYou can set a mimimum distance in between points. This is up to you.\nRight-click the points layer and select attribute table\nYou will need a value column and you will need to adjust the value of each point in your table depending on where it lies within a true or false color image. For this you can reference your key! You should also add a class column that will be the label (i.e., forest, grass, urban).\n\nOption 2: You can create a new points shapefile and manually place your points\n\nrecall step 2 of the unsupervised classification section except geometry type will be points\nOK\nChange the points symbology so it is a bright color and then start adding points\nNow toggle editing and add points using your true or false color as a reference\nEach point you add you have the option to set the value or id (for this you will refer to your key and assess what you see visually in true or false color). Essentially this is just a number you assign it 1-5 based on what class it falls in when you look at an image.\nRight-click the layer after your save your changes and turn off editing and select attribute table to see how this looks. Feel free to add more columns to match your key. You should also add a class column that will be the label (i.e., forest, grass, urban).\n\n\nConsiderations:\n\nThe first option is random so you might get some points that fall within vegetation pixels and way more that fall within water pixels so there is a bias\nThe second option is tedious but you have full control over placement. Shoot for at least 10 points per class, so 50 points in total if you are trying to classify the image into 5 distinct classes.\n\n\nHere is how they might be dispersed:\n\nInstall a dependency for dzetsaka\n\nThere is a python library we need in order to run classification using dzetsaka\nSelect the plugins tab and select python console\nAt the bottom of your screen type this and press enter\n\n\n\nimport pip\n\nNow type this and press enter\n\npip.main(['install', 'scikit-learn'])\n\nWARNING: pip is being invoked by an old script wrapper. This will fail in a future version of pip.\nPlease see https://github.com/pypa/pip/issues/5599 for advice on fixing the underlying issue.\nTo avoid this problem you can invoke Python with '-m pip' instead of running pip directly.\n\n\nRequirement already satisfied: scikit-learn in /Users/wancher/Documents/thesis/env/lib/python3.13/site-packages (1.6.1)\n\n\n\nRequirement already satisfied: numpy&gt;=1.19.5 in /Users/wancher/Documents/thesis/env/lib/python3.13/site-packages (from scikit-learn) (2.2.2)\n\n\n\nRequirement already satisfied: scipy&gt;=1.6.0 in /Users/wancher/Documents/thesis/env/lib/python3.13/site-packages (from scikit-learn) (1.15.1)\n\n\n\nRequirement already satisfied: joblib&gt;=1.2.0 in /Users/wancher/Documents/thesis/env/lib/python3.13/site-packages (from scikit-learn) (1.4.2)\n\n\n\nRequirement already satisfied: threadpoolctl&gt;=3.1.0 in /Users/wancher/Documents/thesis/env/lib/python3.13/site-packages (from scikit-learn) (3.5.0)\n\n\n\n[notice] A new release of pip is available: 24.3.1 -&gt; 25.0.1\n[notice] To update, run: pip install --upgrade pip\n\n\n\n0\n\n\n\nTrain a model:\n\nIn the processing toolbox select dzetsaka\nClassification tool\nTrain algorithm. Here are the parameters used (you can you a composite image with this tool):\n\n\nPredictions from a trained model:\n\nOnce you have saved your models for each band you are ready to make predictions (I saved three models for bands 6, 5, and 4 from a Landsat 1 image)\nOpen the processing toolbox –&gt; dzetsaka\nClassification tool\nPredict model\nInput raster: Landsat B4 clipped to start\nModel learned is my B4 model from the above step\nOutput raster is saved in output data folder as a tif\nConfidence raster is saved in output data folder as a tif with a unique name\nRUN\nChange layer symbology to match your key\n\n\n\n\n\n\n\n\nWhat is your research question?\nDid the unsupervised or supervised classification perform better and what makes you say so?\nWhat is the K-Means clustering algorithm doing? Check out google or the QGIS documentation for the tool\nWhat is the K nearest neighbors algorithm doing?\nWhat kinds of biases could be introduced in the training process?\nHow was your training data distributed spatially? Did you favor a particular area of the image?\nAround how many observations did you have for each class?\nWhat input raster bands did you use when predicting?\nInsert screenshots of the unsupervised result, and your supervised results with brief figure captions.\n\n\n\n\n\n\n\nIf you think back to lab 2; you performed change detection using R and indexed images. For example, NDVI change between 2019 to 2024.\nUsing your additional image dates you will run the supervised classification tool again, using the same training data.\nYou will perform post classification change detection, and this can be done a few different ways. For example we can obtain the count of pixels in each class and multiply this by pixel area to see how the surface area of a class changes over time. Or it could be framed in terms of class change (i.e., healthy forest to unhealthy forest). Just using your supervised classification maps for each image date you will toggle through them and write 2-3 sentences about the change you see visually.\nNow you can right-click each of your output supervised layers and select properties then histogram and compute histogram. Frequency (on the y axis is the pixel count and Pixel value is the class it belongs to). Take the frequency of the pixels in each class divided by the total to get proportion of the image that belongs to each class (this can then be multiplied by pixel area). Or you might find other ways to get pixel counts.\nThis last part will be up to you to create additional supervised images (however many help your research question), and then create some type of summary of the pixels in each class and how this has changed over time. Feel free to use google to find ways to get pixel counts of a raster or create attribute tables for a raster. Please submit some type of visualization of the change. Whether it is a graph or a map, don’t overburden yourself but try to do a little research about how people typically do this in QGIS or excel.\n\n\n\n\nWhat did you learn?\nWhat are the limitations?\nHow would you do this differently next time?"
  },
  {
    "objectID": "instructions/Lab3/index.html#overview",
    "href": "instructions/Lab3/index.html#overview",
    "title": "Lab three instructions",
    "section": "",
    "text": "You will download Landsat imagery on EarthExplorer of the Mt St Helens area, before and after the 1980 eruption to answer a brief research question of something that interests you (for example: how long did it take for vegetation recovery after the eruption?). The research question will guide the image dates and number of images you download. It’s been almost 45 years, so using Landsat you should be able and ask a pretty interesting question about this. If visible bands are not available you can download any raw bands that are available.\nYou will work image by image, and your task is to classify pixels in the image to match a classification schema of interest (i.e., landcover or forest type).\nYou will be using your image interpretation skills to generate training data\n\nAt this point you can navigate to EarthExplorer, download your Landsat images and then read on.\n\nThis lab will be divided into three parts.\nPart one: Unsupervised classification.\n\nThe tool you are going to run in QGIS will basically group pixels that have similar spectral characteristics to classes or clusters without any additional information from the user (you).\nFor example: pixels that have really high NIR values could be grouped as one cluster because maybe these pixels have vegetation in them.\n\nPart two: Supervised classification.\n\nThe tool will take additional information (training data) and then it will look at the spectral characteristics of each pixel and group into classes accordingly. You are going to be the source of this training data (more on this below).\n\nPart three: Change detection\n\nYou will run the supervised classification algorithms for your remaining image dates."
  },
  {
    "objectID": "instructions/Lab3/index.html#part-one",
    "href": "instructions/Lab3/index.html#part-one",
    "title": "Lab three instructions",
    "section": "",
    "text": "First, consider: what is it you would like to investigate about the landscape? How will you set up your classification schema? Create a classification key with class, value, and color as columns for reference. You have to freedom over what this looks like and it is purely for reference. Use excel, notepad, or word create one. Here is mine:\n\n\n\nClass\nValue\nColor\n\n\n\n\nHealthy Forest\n1\nGreen\n\n\nUrban\n2\nGray\n\n\nWater\n3\nBlue\n\n\nGrass\n4\nYellow\n\n\nUnhealthy Forest\n5\nBrown\n\n\n\n\n\n\nPrepare the Data:\n\nLoad layers into QGIS. Just use one image date to start\nCreate a true color composite or false color composite for reference using the Build Virtual Raster Tool.\n\nRaster tab (top of the screen)\nMiscellaneous\nBuild Virtual Raster\nSelect input layers\nSet Resolution to highest\nPlace each input file in separate band\nRUN\n\nRemember that the virtual output you created does not automatically save.\n\nRight-click the virtual layer\nExport\nSave in the output data as a tif\nBe specific with how you name (i.e., FCC_1979.tif)\n\n\nDefine Area of Interest:\n\nCreate a polygon shapefile around Mt. St. Helens to use as a clipping mask.\nLayer tab (top of the screen)\nCreate layer\nNew shapefile layer\nFilename is up to you\nGeometry type: polygon\nRUN\nRight-click the shapefile in your layers tab\nSelect “Toggle editing”\nAdd polygon (see screenshot) then Click somewhere on the screen to begin drawing and complete the polygon by right-clicking\nRight-click and select toggle editing again to turn it off\n\n\nClip Raster by Mask:\n\nClip your images to the shapefile. The shapefile will act as a cookie cutter.\nSearch the processing toolbox for “Clip raster by mask layer”. If you don’t see the toolbox on the right side of QGIS press CTRL + ALT + T.\nInput layer: Landsat raw band raster (you will have to do this for each raw band raster instead of composites because the classification tool will not work for a composite image).\nMask layer: The shapefile you created\nClipped mask: Save this in your output data as a TIF (i.e., Landsat_1979_B5_CLIPPED.tif)\nRUN\nRinse and repeat for the other bands\n\nK-Means Clustering:\n\nSearch for K-means clustering for grids in your toolbox window\nInput the clipped rasters from above. Set the Number of Clusters based on your classification key (for example, 5 clusters for 5 land cover classes).\nAdjust the Iterations to control how many times the algorithm tries to classify pixels (usually around 10-20 iterations). More on the tool\nRun the tool. See the parameters I used:\n\n\nClassify the Output:\n\nAfter running the tool, the output will be a classified raster. #WOW\n\nDo a quick export of the clusters layer in your layers pane and save it as a tif. It won’t save if you reload QGIS because it is just a temporary file at the moment.\nOnce you save it, load it into your layers and change the symbology to apply a random color palette or directly adjust the colors according to your KEY!\n\nRight-click the output clusters layer\nProperties\nSymbology\nChange the render type to paletted/ unique values\nPress classify\nPress apply\nChange the colors to match your key (read below)\n\nNow, use a true color or false color composite as a reference (toggle your layer on and off) to visually inspect the output and match it with the classification key. Take a screenshot of your classified output after setting the colors as close to your key as possible. Do this to the best of your ability.\n\n\nSee if your output looks any better than this but remember this was unsupervised:"
  },
  {
    "objectID": "instructions/Lab3/index.html#part-two",
    "href": "instructions/Lab3/index.html#part-two",
    "title": "Lab three instructions",
    "section": "",
    "text": "Collect Training Data (take your pick of option 1 or option 2):\n\nOption 1: You can search the toolbox for a tool called random points in extent\n\n10 points minimum per class (so 50 points if you are going for 5 classes)\ninput extent: calculate from layer and use the shapefile from step 2 in the unsupervised classification section.\nYou can set a mimimum distance in between points. This is up to you.\nRight-click the points layer and select attribute table\nYou will need a value column and you will need to adjust the value of each point in your table depending on where it lies within a true or false color image. For this you can reference your key! You should also add a class column that will be the label (i.e., forest, grass, urban).\n\nOption 2: You can create a new points shapefile and manually place your points\n\nrecall step 2 of the unsupervised classification section except geometry type will be points\nOK\nChange the points symbology so it is a bright color and then start adding points\nNow toggle editing and add points using your true or false color as a reference\nEach point you add you have the option to set the value or id (for this you will refer to your key and assess what you see visually in true or false color). Essentially this is just a number you assign it 1-5 based on what class it falls in when you look at an image.\nRight-click the layer after your save your changes and turn off editing and select attribute table to see how this looks. Feel free to add more columns to match your key. You should also add a class column that will be the label (i.e., forest, grass, urban).\n\n\nConsiderations:\n\nThe first option is random so you might get some points that fall within vegetation pixels and way more that fall within water pixels so there is a bias\nThe second option is tedious but you have full control over placement. Shoot for at least 10 points per class, so 50 points in total if you are trying to classify the image into 5 distinct classes.\n\n\nHere is how they might be dispersed:\n\nInstall a dependency for dzetsaka\n\nThere is a python library we need in order to run classification using dzetsaka\nSelect the plugins tab and select python console\nAt the bottom of your screen type this and press enter\n\n\n\nimport pip\n\nNow type this and press enter\n\npip.main(['install', 'scikit-learn'])\n\nWARNING: pip is being invoked by an old script wrapper. This will fail in a future version of pip.\nPlease see https://github.com/pypa/pip/issues/5599 for advice on fixing the underlying issue.\nTo avoid this problem you can invoke Python with '-m pip' instead of running pip directly.\n\n\nRequirement already satisfied: scikit-learn in /Users/wancher/Documents/thesis/env/lib/python3.13/site-packages (1.6.1)\n\n\n\nRequirement already satisfied: numpy&gt;=1.19.5 in /Users/wancher/Documents/thesis/env/lib/python3.13/site-packages (from scikit-learn) (2.2.2)\n\n\n\nRequirement already satisfied: scipy&gt;=1.6.0 in /Users/wancher/Documents/thesis/env/lib/python3.13/site-packages (from scikit-learn) (1.15.1)\n\n\n\nRequirement already satisfied: joblib&gt;=1.2.0 in /Users/wancher/Documents/thesis/env/lib/python3.13/site-packages (from scikit-learn) (1.4.2)\n\n\n\nRequirement already satisfied: threadpoolctl&gt;=3.1.0 in /Users/wancher/Documents/thesis/env/lib/python3.13/site-packages (from scikit-learn) (3.5.0)\n\n\n\n[notice] A new release of pip is available: 24.3.1 -&gt; 25.0.1\n[notice] To update, run: pip install --upgrade pip\n\n\n\n0\n\n\n\nTrain a model:\n\nIn the processing toolbox select dzetsaka\nClassification tool\nTrain algorithm. Here are the parameters used (you can you a composite image with this tool):\n\n\nPredictions from a trained model:\n\nOnce you have saved your models for each band you are ready to make predictions (I saved three models for bands 6, 5, and 4 from a Landsat 1 image)\nOpen the processing toolbox –&gt; dzetsaka\nClassification tool\nPredict model\nInput raster: Landsat B4 clipped to start\nModel learned is my B4 model from the above step\nOutput raster is saved in output data folder as a tif\nConfidence raster is saved in output data folder as a tif with a unique name\nRUN\nChange layer symbology to match your key\n\n\n\n\n\n\n\n\nWhat is your research question?\nDid the unsupervised or supervised classification perform better and what makes you say so?\nWhat is the K-Means clustering algorithm doing? Check out google or the QGIS documentation for the tool\nWhat is the K nearest neighbors algorithm doing?\nWhat kinds of biases could be introduced in the training process?\nHow was your training data distributed spatially? Did you favor a particular area of the image?\nAround how many observations did you have for each class?\nWhat input raster bands did you use when predicting?\nInsert screenshots of the unsupervised result, and your supervised results with brief figure captions."
  },
  {
    "objectID": "instructions/Lab3/index.html#part-three",
    "href": "instructions/Lab3/index.html#part-three",
    "title": "Lab three instructions",
    "section": "",
    "text": "If you think back to lab 2; you performed change detection using R and indexed images. For example, NDVI change between 2019 to 2024.\nUsing your additional image dates you will run the supervised classification tool again, using the same training data.\nYou will perform post classification change detection, and this can be done a few different ways. For example we can obtain the count of pixels in each class and multiply this by pixel area to see how the surface area of a class changes over time. Or it could be framed in terms of class change (i.e., healthy forest to unhealthy forest). Just using your supervised classification maps for each image date you will toggle through them and write 2-3 sentences about the change you see visually.\nNow you can right-click each of your output supervised layers and select properties then histogram and compute histogram. Frequency (on the y axis is the pixel count and Pixel value is the class it belongs to). Take the frequency of the pixels in each class divided by the total to get proportion of the image that belongs to each class (this can then be multiplied by pixel area). Or you might find other ways to get pixel counts.\nThis last part will be up to you to create additional supervised images (however many help your research question), and then create some type of summary of the pixels in each class and how this has changed over time. Feel free to use google to find ways to get pixel counts of a raster or create attribute tables for a raster. Please submit some type of visualization of the change. Whether it is a graph or a map, don’t overburden yourself but try to do a little research about how people typically do this in QGIS or excel.\n\n\n\n\nWhat did you learn?\nWhat are the limitations?\nHow would you do this differently next time?"
  },
  {
    "objectID": "instructions/Lab4.2/index.html",
    "href": "instructions/Lab4.2/index.html",
    "title": "Lab four.2 instructions",
    "section": "",
    "text": "Photogrammetry! (Files located in R drive Shared folder)\nRecall from lecture that we can make 3D from pictures! You could do this lab at various scales. For example, you could take various photos of any subject or object of interest from many angles and perspectives and stitch them together. (There are example images that you could use in the R drive that showcase this. Focus first on the drone imagery and then try to use different images to complete the steps below if you are feeling fancy).\nWe will focus on the same study area as Lab 4.1, except we will be using drone images in true color, instead of LiDAR point clouds. Hence, the file type will be jpeg.\nYou will use Agisoft to generate a model, mesh, and point cloud from your photos.\n\nSteps to Process in Agisoft:\n\nSearch for Agisoft on your machine. Should be Windows 64-bit professional. Agisoft is not free it is recommended to use the computers in SSIL to complete this lab.\nDrag your photos into the software. They will be stored under a “Chunk”.\nRight-click the chunk with your images → Process → Align Photos.\nRight-click → Process → Build Model.\nRight-click → Process → Build Texture.\nRight-click → Process → Build Point Cloud.\nRight-click → Export → Export Point Cloud.\n\n\n\nPost-Processing:\nTake screenshots of your model, mesh, and point clouds. What is the utility of each type of file that you rendered?\nIf it does not automatically display your model, mesh (texture), and point cloud, you need select the Model tab at the top of your screen, then “View mode.” The model is under model “solid”. You can display the texture in color.\nIt is suggested that you run your .las or .laz file that is generated from the steps above through Part 1 from last week to process it further for DSM, DTM, and Hillshades. These can then be compared to the results from the NOAA LiDAR data from last week.\nAs always, try to drag any TIFFs generated from your processing into QGIS and manipulate the symbology so you can infer more information. Sometimes it is insufficient to rely on one software for try to interpret data."
  },
  {
    "objectID": "code/HistogramRasterBands/index.html",
    "href": "code/HistogramRasterBands/index.html",
    "title": "Graphing raster distribution",
    "section": "",
    "text": "Histograms are the best way to get a glimpse of data, no? This code is useful if you have a multiband raster stack and want to plot the data distribution on a normalized scale. My output from this got a lot of thumbs ups at AGU this year.\n\nlibrary(terra)\n\nterra 1.8.5\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ tidyr::extract() masks terra::extract()\n✖ dplyr::filter()  masks stats::filter()\n✖ dplyr::lag()     masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(ggridges)\nlibrary(dplyr)\nlibrary(RColorBrewer)\n\n# path to your multiband raster\npath &lt;- \"../FullComp_Dalton_2015.tif\"\n\n\n#example file\nr &lt;- rast(path)\nband_names &lt;- names(r)\nnormalize_layer &lt;- function(layer) {\n  min_val &lt;- min(layer[], na.rm = TRUE)\n  max_val &lt;- max(layer[], na.rm = TRUE)\n  normalized &lt;- (layer - min_val) / (max_val - min_val)\n  return(normalized)\n}\n\nnormalized_rasters &lt;- lapply(1:nlyr(r), function(i) {\n  band &lt;- r[[i]]\n  normalized_band &lt;- normalize_layer(band)\n  return(normalized_band)\n})\n\n# stack the normalized rasters\nnormalized_r &lt;- rast(normalized_rasters)\n\nConvert raster to df and plot it:\n\n#convert to df\ndf &lt;- as.data.frame(normalized_r, xy = FALSE, na.rm = TRUE)\ndf_long &lt;- df %&gt;%\n  pivot_longer(cols = everything(), \n               names_to = \"Band\", \n               values_to = \"Value\")\ndf_long_sampled &lt;- df_long %&gt;%\n  sample_n(500)\n\n#ridge plot\n#display.brewer.all()\ncolors &lt;- colorRampPalette(brewer.pal(11, \"Paired\"))(57)  # 57 colors\n\nplt &lt;- ggplot(df_long_sampled, aes(x = Value, y = Band, fill = Band)) +\n  geom_density_ridges_gradient(scale = 10, rel_min_height = 0.002, linewidth = 0.35) +\n  scale_fill_manual(values = colors)+\n  #scale_fill_viridis_d(option = \"plasma\") +  \n  theme(\n    axis.title = element_blank(),  \n    axis.text.x = element_blank(),\n    axis.text.y = element_text(size = 12, color = \"black\", face = \"bold\"),\n    axis.ticks = element_blank()   \n  )\n#plt\n\nAny band denoted with _1 is derived from a spring composite, _2, a summer composite, and _3, a fall composite. Hence, the color grouping in the plot. For context, these are layers that are used as inputs into a random forest model prior to remove correlated variables."
  },
  {
    "objectID": "code/RasterSieving/index.html",
    "href": "code/RasterSieving/index.html",
    "title": "Raster manipulation using terra",
    "section": "",
    "text": "This R script reads in NDWI images derived the blue-red/blue+red equation, converts them to binary images using a threshold from the literature, and then removes outlier pixels which are disconnected from large water bodies.\n\n# setting up\nlibrary(terra)\n\nterra 1.8.5\n\n\nJust working with one file in this example. But you can imagine reading in a list of files and performing this operation iteratively with a for loop.\n\nr &lt;- rast(\"../ndwi_ice_small.tif\")\nplot(r)\n\n\n\n\n\n\n\n\nSo this is what the NDWI image looks like. Let’s visualize as lake vs non lake.\n\nlake_mask &lt;- r &gt; 0.25\nplot(lake_mask)\n\n\n\n\n\n\n\n\nThis looks good but if you look at some of the isolated yellow pixels, they would then be considered a lake pixel even if disconnected from the larger lake. So we remove those.\n\n# function to sieve\nlake_sieve &lt;- function(ndwi_thres_raster) {\n  # get connected components\n  connected_comp &lt;- patches(ndwi_thres_raster, directions = 4, zeroAsNA = TRUE)\n  components &lt;- unique(values(connected_comp), na.rm = TRUE)\n  components &lt;- components[components != 0 & !is.na(components)]\n  cell_indices &lt;- unique(values(connected_comp, na.rm = TRUE))\n  # empty mask for valid lakes\n  valid_lake_mask &lt;- rast(ndwi_thres_raster)\n  values(valid_lake_mask) &lt;- 0\n  min_pixel &lt;- 10\n  min_width &lt;- 1\n  #loop over each ndwi scene\n  for (comp_id in components) {\n    # get cell indices for the current cc\n    cell_indices &lt;- which(values(connected_comp) == comp_id)\n    if (length(cell_indices) &lt; min_pixel) next\n    # convert cell indices to coordinates\n    coords &lt;- xyFromCell(ndwi_thres_raster, cell_indices)\n    width &lt;- length(unique(coords[, \"x\"]))\n    height &lt;- length(unique(coords[, \"y\"]))\n    # check if the component meets width/height requirements\n    if (width &lt;= min_width || height &lt;= min_width) next\n    values(valid_lake_mask)[cell_indices] &lt;- 1 #update valid lake\n  }\n  return(valid_lake_mask)\n}\n\nApply the function\n\nsieved_r &lt;- lake_sieve(lake_mask)\nplot(sieved_r)\n\n\n\n\n\n\n\n\nLooking good!! This is just a qualitative sieving technique and could easily adapt to more stats-based approaches. This layer can now be used to mask other rasters to. In my approach, I mask images in the red and panchromatic wavelengths by this image to isolate lakes and apply radiative transfer equations."
  },
  {
    "objectID": "code/RandomForest/index.html",
    "href": "code/RandomForest/index.html",
    "title": "Fitting Random Forests",
    "section": "",
    "text": "Libraries\n\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ forcats   1.0.0     ✔ readr     2.1.5\n✔ ggplot2   3.5.2     ✔ stringr   1.5.1\n✔ lubridate 1.9.4     ✔ tibble    3.2.1\n✔ purrr     1.0.4     ✔ tidyr     1.3.1\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n── Attaching packages ────────────────────────────────────── tidymodels 1.2.0 ──\n\n✔ broom        1.0.7     ✔ rsample      1.2.1\n✔ dials        1.3.0     ✔ tune         1.2.1\n✔ infer        1.0.7     ✔ workflows    1.1.4\n✔ modeldata    1.4.0     ✔ workflowsets 1.1.0\n✔ parsnip      1.2.1     ✔ yardstick    1.3.1\n✔ recipes      1.1.0     \n\n── Conflicts ───────────────────────────────────────── tidymodels_conflicts() ──\n✖ scales::discard() masks purrr::discard()\n✖ dplyr::filter()   masks stats::filter()\n✖ recipes::fixed()  masks stringr::fixed()\n✖ dplyr::lag()      masks stats::lag()\n✖ yardstick::spec() masks readr::spec()\n✖ recipes::step()   masks stats::step()\n• Dig deeper into tidy modeling with R at https://www.tmwr.org\n\nrandomForest 4.7-1.2\n\nType rfNews() to see new features/changes/bug fixes.\n\n\nAttaching package: 'randomForest'\n\n\nThe following object is masked from 'package:ggplot2':\n\n    margin\n\n\nThe following object is masked from 'package:dplyr':\n\n    combine\n\n\n\nAttaching package: 'rlang'\n\n\nThe following objects are masked from 'package:purrr':\n\n    %@%, flatten, flatten_chr, flatten_dbl, flatten_int, flatten_lgl,\n    flatten_raw, invoke, splice\n\n\n\n\nClean training data\n\n#annual csvs\nfiles &lt;- list.files(\"data/processed/csv/\", pattern = \"pixel-vals-fire\", full.names = TRUE)\n\nclean_df &lt;- function(file){\n  #read in\n  df &lt;- read.csv(file)\n\n  #convert geo column to lat/lon\n  matches &lt;- regmatches(df$.geo, regexec('\"coordinates\":\\\\[([-0-9.]+),([-0-9.]+)\\\\]', df$.geo))\n  coords &lt;- do.call(rbind, matches)\n  \n  #add lat long and convert time since fire to categorical\n  df_clean &lt;- df %&gt;% \n    mutate(lon = as.numeric(coords[, 2]),\n           lat = as.numeric(coords[, 3]),\n           tsf_0_5 = tsf &gt;=0 & tsf &lt; 5,\n           tsf_5_10 = tsf &gt;=5 & tsf &lt; 10,\n           tsf_10_15 = tsf &gt;=10 & tsf &lt; 15,\n           tsf_15_20 = tsf &gt;=15 & tsf &lt; 20)%&gt;%\n    select(-.geo, -system.index, -PSP, -Year, -tsf, \n           -all_of(starts_with(\"severity\")), -SPP_count, -total_fires)\n  \n  if (ncol(df_clean)==38){\n    return(df_clean)\n  }\n}\n\n#apply the function and bind into one dataframe\nclean_training_dfs &lt;- lapply(files, clean_df) %&gt;% compact()\ntraining_df &lt;- bind_rows(clean_training_dfs)\n\nImputing missing values with random forest\n\n# Columns to ignore\nignore_cols &lt;- c(\"Biogm2\", \"Species\", \"tsf_0_5\", \"tsf_5_10\", \"tsf_10_15\", \"tsf_15_20\")\n\n# Split the dataframe\ndf_to_impute &lt;- training_df[, !(names(training_df) %in% ignore_cols)]\ndf_ignored &lt;- training_df[, (names(training_df) %in% ignore_cols)]\n\n# miss forest on missing data columns\nset.seed(614)\nimputed_result &lt;- missForest(df_to_impute)\ndf_imputed &lt;- imputed_result$ximp\n\n# recombine\ntraining_df_imputed &lt;- cbind(df_ignored, df_imputed)\n# reorder columns\ntraining_df_imputed &lt;- training_df_imputed[, names(training_df)]\n#write.csv(training_df_imputed, \"data/processed/csv/training_df_imputed.csv\", row.names = FALSE)\n\nModel fitting function (species specific)\n\nspecies &lt;- c(\"black spruce\", \"white spruce\", \"resin birch\", \"quaking aspen\")\n\ntrain_model &lt;- function(df, species, response=\"Biogm2\") {\n  print(paste0(\"running model for: \", species))\n  \n  #filter to one species\n  training_df_one_spp &lt;- training_df_imputed %&gt;% filter(Species == species)\n  predictors &lt;- setdiff(names(training_df_one_spp), c(\"Species\", \"Biogm2\"))#36 before screening\n  formula &lt;- as.formula(paste(response, \"~\", paste(predictors, collapse = \"+\")))\n  \n  #tidy models recipe (swapping in entire dataset)\n  recipe &lt;- recipe(formula = formula, data = training_df_one_spp) %&gt;% \n    step_nzv(all_predictors()) %&gt;%\n    step_corr(all_numeric_predictors(), threshold = 0.80, use = \"pairwise.complete.obs\", method = \"pearson\") %&gt;%\n    step_impute_mean(all_numeric_predictors())%&gt;%#make sure the recipe can handle NAs\n    step_normalize(all_numeric_predictors())\n    \n  #grid search for optimal parms\n  model_specs &lt;- rand_forest(mtry = tune(), \n                             trees = tune(),\n                             min_n = tune()) %&gt;% set_mode(\"regression\") %&gt;% set_engine(\"randomForest\", proximity = TRUE)\n  \n  grid_parms &lt;- expand.grid(mtry = seq(5, 10, 5), \n                            trees = seq(300,800,250), \n                            min_n = seq(1, 12, 6))\n  \n  #cross validation\n  nfold &lt;- 5\n  print(paste0(\"performing cross validation across \", nfold, \" folds\"))\n  pv_folds &lt;- vfold_cv(training_df_one_spp, v = nfold, strata = all_of(response))\n\n  #pull workflow results\n  tuned_results &lt;- workflow() %&gt;% add_recipe(recipe) %&gt;% add_model(model_specs) %&gt;% \n    tune_grid(resamples = pv_folds, grid = grid_parms, metrics = metric_set(rmse, rsq, mae))\n  autoplot(tuned_results)\n  best_params &lt;- select_best(tuned_results, metric=\"rmse\")\n  wflow &lt;- finalize_workflow(workflow() %&gt;% add_recipe(recipe) %&gt;% add_model(model_specs), best_params)\n  \n  #fit across the resamples\n  fit &lt;- fit_resamples(wflow, resamples = pv_folds, metrics = metric_set(rmse, rsq, mae))\n  mean_rmse &lt;- collect_metrics(fit) %&gt;% filter(.metric == \"rmse\") %&gt;% pull(mean)\n  mean_rsq &lt;- collect_metrics(fit) %&gt;% filter(.metric == \"rsq\") %&gt;% pull(mean)\n  \n  #print accuracy across resamples\n  print(paste(\"Mean RMSE across folds: \", mean_rmse))\n  print(paste(\"Mean R² across folds: \", mean_rsq))\n  \n  #pull out-of-fold predictions for accuracy plot\n  ctrl &lt;- control_resamples(save_pred=TRUE)\n  resample_results &lt;- wflow %&gt;% \n    fit_resamples(resamples = pv_folds, control = ctrl)\n  all_preds &lt;- resample_results %&gt;%\n    collect_predictions() %&gt;%\n    mutate(Species = species)\n  write.csv(all_preds, paste0(\"data/processed/csv/folded_pred_vs_obs_\", \n                             gsub(\" \", \"_\", species), \".csv\"))\n  \n  #store and save final fit\n  final_fit &lt;- fit(wflow, training_df_one_spp)\n  filename &lt;- paste0(\"models/final_fit_\", gsub(\" \", \"_\", species), \".rds\")\n  #saveRDS(final_fit, file = filename)\n  print(paste(\"Model saved to:\", filename))\n  \n  return(list(model = final_fit, \n              species = species, \n              mean_rmse = mean_rmse, \n              mean_rsq = mean_rsq))\n}\n\n#run the models\nmodel_output &lt;- lapply(species, function(spp){train_model(training_df_imputed,species=spp)})\n\nPrinting model accuracy metrics\n\ncv_summary &lt;- map_dfr(model_output, function(x) {\n  tibble(\n    Species = x$species,\n    RMSE_cv = x$mean_rmse,\n    R2_cv = x$mean_rsq\n  )\n})"
  },
  {
    "objectID": "code/VariableImportance/explanatory_variables.html",
    "href": "code/VariableImportance/explanatory_variables.html",
    "title": "Plotting variable importance",
    "section": "",
    "text": "library(pdp)\nlibrary(tidymodels)\nlibrary(randomForest)\nlibrary(vip)\nlibrary(tidytext)\n\nModel fits obtained from model_fitting.Rmd\n\nmodel_files &lt;- list.files(\"models/\", full.names = TRUE)\n\nmodels &lt;- setNames(\n  lapply(model_files, readRDS),\n  tools::file_path_sans_ext(basename(model_files))\n)\n\n#palette\ncolors &lt;- c(\"Alaskan birch\" = \"#67161CFF\",\"Black spruce\" = \"#3F6148FF\",\n            \"White spruce\" = \"#A4804CFF\",\"Trembling aspen\" = \"#4B5F80FF\")\n\ntraining_df_imputed &lt;- read.csv(\"data/processed/csv/training_df_imputed.csv\")\n\nPartial dependence on most important variables\n\n#iterate over each model and plot partial dependence\npdp_lines &lt;- list()\nvip_all_spp &lt;- list()\n\nfor (spp in names(models)) {\n  model &lt;- models[[spp]]\n  fit &lt;- extract_fit_parsnip(model)\n  recipe &lt;- extract_recipe(model)\n  \n  #cleaned predictor variables\n  training_data &lt;- training_df_imputed %&gt;% filter(Species == gsub(\"final_fit_\", \"\", spp) %&gt;% gsub(\"_\", \" \", .))\n  training_data &lt;- training_data %&gt;%\n    mutate(across(where(is.integer), as.numeric))\n  predictors &lt;- bake(recipe, new_data = training_data) %&gt;% as.data.frame()#apply tidymodel preprocessing steps\n  \n  #conditional renaming for two species\n  if (spp == paste0(\"final_fit_quaking_aspen\")){\n    spp &lt;- paste0(\"final_fit_trembling_aspen\")\n    }\n  if (spp == paste0(\"final_fit_resin_birch\")){\n    spp &lt;- paste0(\"final_fit_alaskan_birch\")\n    }\n  \n  #variable importance\n  vip &lt;- vi(fit)\n  vip$Species &lt;- tools::toTitleCase(strsplit(spp, \"_\")[[1]][3])%&gt;%\n    paste0(\" \", strsplit(spp, \"_\")[[1]][4])\n  vip_all_spp[[spp]] &lt;- vip\n  \n  #partial dependence results\n  # pdp_res &lt;- pdp::partial(\n  #   object = fit$fit,\n  #   pred.var = \"evi_summer\",\n  #   train = predictors,\n  #   type = \"regression\"\n  # )\n  # \n  # pdp_res$Species &lt;- tools::toTitleCase(strsplit(spp, \"_\")[[1]][3])%&gt;%\n  #   paste0(\" \", strsplit(spp, \"_\")[[1]][4])\n  # pdp_lines[[spp]] &lt;- pdp_res\n}\n\npdp_df &lt;- bind_rows(pdp_lines)\nvip_df &lt;- bind_rows(vip_all_spp)\n\npdp_df &lt;- pdp_df %&gt;%\n  mutate(Species = factor(Species, levels = c(\"Black spruce\", \"White spruce\", \n                                              \"Alaskan birch\", \"Trembling aspen\")))\nvip_df &lt;- vip_df %&gt;%\n  mutate(Species = factor(Species, levels = c(\"Black spruce\", \"White spruce\", \n                                              \"Alaskan birch\", \"Trembling aspen\")))\n\nPlotting variable importance and partial dependence\n\nimportance_plot &lt;- vip_df%&gt;%\n    group_by(Species) %&gt;%\n    slice_max(order_by = Importance, n = 10, with_ties = FALSE) %&gt;%\n    ungroup() %&gt;%\n    mutate(Variable = reorder_within(Variable, Importance, Species))%&gt;%\n    ggplot(aes(x=Importance, y=Variable, fill=Species))+\n    geom_bar(stat=\"identity\")+\n    scale_fill_manual(values=colors)+\n    scale_y_reordered()+\n    facet_wrap(~Species, scales = \"free\")+\n    theme_bw(base_family = \"Times New Roman\")+\n    labs(x=\"Variable importance\")+\n    theme(axis.text = element_text(color = \"black\", size = 14),\n          #axis.text.x = element_blank(),\n          plot.title = element_text(color = \"black\", size = 20),\n          axis.title.y = element_blank(),\n          axis.title.x = element_text(color = \"black\", size = 18),\n          strip.text = element_text(color = \"black\", size = 16),\n          legend.position = \"none\",\n          panel.grid.major = element_line(color = \"gray20\", linewidth = .25),\n          panel.grid.minor = element_blank())\nimportance_plot\n\n#visualize pdp\nggplot(pdp_df, aes(x = evi_summer, y = yhat, color = Species)) +\n  geom_line(size = 1) +\n  #facet_grid(~Species)+\n  scale_color_manual(values=colors)+\n  labs(\n    x = \"Summer Enhanced Vegetation Index (Normalized)\",\n    y = \"Predicted Biomass (g/m²)\"\n  ) +\n  theme_minimal(base_family = \"Times New Roman\")\n\n\npng(\"results/graphs/variable_importance.png\", width = 9.5, height = 6, units = \"in\", res = 300)\nprint(importance_plot)\ndev.off()"
  },
  {
    "objectID": "code/RandomForestAccuracy/model_accuracy.html",
    "href": "code/RandomForestAccuracy/model_accuracy.html",
    "title": "Plotting prediction accuracy",
    "section": "",
    "text": "library(tidymodels)\nlibrary(ggplot2)\nlibrary(viridis)\nlibrary(patchwork)\nlibrary(Metrics)\n\nModel fits obtained from model_fitting.Rmd\n\nfiles &lt;- list.files(\"data/processed/csv\", pattern = \"folded_\", full.names = TRUE)\n\n#read in csvs from model fitting code\ndfs &lt;- lapply(files, read.csv)\nmain_plot_df &lt;- do.call(rbind, dfs) %&gt;%\n  mutate(Species = case_when(\n    Species == \"black spruce\" ~ \"Black spruce\",\n    Species == \"white spruce\" ~ \"White spruce\",\n    Species == \"resin birch\" ~ \"Alaskan birch\",\n    Species == \"quaking aspen\" ~ \"Trembling aspen\",\n    TRUE ~ Species\n  ))\n\nVisualize\n\n#factor the species\nmain_plot_df &lt;- main_plot_df %&gt;%\n  mutate(Species = factor(Species, levels = c(\"Black spruce\", \"White spruce\", \"Alaskan birch\", \"Trembling aspen\")))%&gt;%\n  rename(Predicted = .pred,\n         Observed = Biogm2)\n\n#summary table \nsummary_df &lt;- main_plot_df %&gt;%\n  group_by(Species) %&gt;%\n  summarise(\n    Observed_Min = round(min(Observed), 1),\n    Observed_Max = round(max(Observed), 1),\n    Observed_Mean = round(mean(Observed), 1),\n    Predicted_Min = round(min(Predicted), 1),\n    Predicted_Max = round(max(Predicted), 1),\n    MAE = round(yardstick::mae_vec(Observed, as.numeric(Predicted)), 1),\n    RMSE = round(yardstick::rmse_vec(Observed, as.numeric(Predicted)), 1),\n    R2 = round(yardstick::rsq_vec(Observed, as.numeric(Predicted)), 1)\n  )\n\n#join model metrics df with main\nannot_df &lt;- left_join(main_plot_df, summary_df, by = \"Species\") %&gt;%\n  group_by(Species) %&gt;%\n  slice(1) %&gt;%\n  ungroup() %&gt;%\n  mutate(\n    label = paste0(\n      \"R² = \", R2, \"\\n\",\n      \"RMSE = \", RMSE, \" g m-2\\n\",\n      \"MAE = \", MAE, \" g m-2\"\n    ),\n    xpos = 0,\n    ypos = 1700\n  )\n\n#plot\nvalidation_plot &lt;- ggplot(main_plot_df, aes(x = Predicted, y = Observed, color = abs(Observed - Predicted))) +\n  geom_point(size = 4, alpha = .5, shape = 16) +\n  geom_smooth(method = \"lm\", color = \"black\", linetype = \"solid\", se = FALSE) +\n  geom_abline(slope = 1, intercept = 0, linetype = \"dashed\") +\n  scale_color_viridis(option = \"turbo\", direction = 1) +\n  facet_wrap(~Species) +\n  geom_text(data = annot_df, aes(x = xpos, y = ypos, label = label),\n            inherit.aes = FALSE, size = 4.5, family = \"Times New Roman\", hjust = 0) +\n  theme_bw(base_family = \"Times New Roman\") +\n  scale_x_continuous(limits = c(0, 2000)) +\n  scale_y_continuous(limits = c(0, 2000)) +\n  labs(x = \"Biomass Predicted (g m-2)\",\n       y = \"Biomass Observed (g m-2)\",\n       color = \"Difference (g m-2)\") +\n  theme(\n    axis.text = element_text(color = \"black\", size = 14),\n    axis.text.x = element_text(color = \"black\", size = 14),\n    plot.title = element_text(color = \"black\", size = 20),\n    axis.title.y = element_text(color = \"black\", size = 18),\n    axis.title.x = element_text(color = \"black\", size = 18, vjust = -.25),\n    strip.text = element_text(color = \"black\", size = 13.5),\n    legend.position = \"inside\",\n    legend.position.inside = c(0.9, 0.125),\n    legend.background = element_blank(),\n    legend.frame = element_rect(color = \"black\"),\n    legend.box.background = element_rect(),\n    legend.key.size = unit(0.4, \"cm\"),\n    legend.title = element_text(size = 10),\n    legend.spacing = unit(0.2, \"cm\"),\n    legend.text = element_text(color = \"black\", size = 10),\n    panel.grid.major = element_line(color = \"gray70\", linewidth = .25),\n    panel.grid.minor = element_blank()\n  )\nvalidation_plot\n\nSaving chunk\n\npng(\"results/graphs/model_accuracy.png\", width = 7, height = 6, units = \"in\", res = 300)\nprint(validation_plot)\ndev.off()"
  },
  {
    "objectID": "cv.html",
    "href": "cv.html",
    "title": "Curriculum Vitae",
    "section": "",
    "text": "You can view or download my CV here:\n📄 View / Download CV"
  }
]