{
  "hash": "1f6bd75dc6246ba3785399fba40ac6f6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Lab two instructions\nauthor: 'Wesley Rancher'\ndate: 2024-1-5\ndate-modified: last-modified\ncategories: [R, image-enhancement]\ntitle-block-banner: false\ntitle-block-banner-color: white\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n### **Summary**\n\n-   The objective of this lab is to enhance satellite imagery using a few different techniques. This lab assumes no prior coding experience and is commented thoroughly to explain what each line is doing. After setting things up it should run fairly smoothly but please ask if you need help!! I'm not trying to throw you to the wolves but learning R (among other tools), is an extremely useful skill in GIScience.\n\n-   This code script is available in the R drive as \"enhance.qmd\". Copy it to your folder.\n\n-   As for data, you have been provided images in the class R drive. Copy them to your project folder where you prefer to store data.\n\n-   We will be working with Landsat 8/9 (Level 1 and 2) and Sentinel 2A imagery from 2019-2024. You should look up these satellites and sensors to clarify what the levels indicate and what information or bands might be present in the images.\n\n-   In brief, you will start by getting acquianted with R and RStudio and figuring out how to read in data. You will then move to displaying your data and exploring summary statistics. This will give you a lay of the land, and then you can go on to enhancement techniques. These instructions will outline how to do this for a subset of the data (you will just need to replicate the steps for ALL of your data). The last step of this lab is to compare across datasets and across time and infer based on what you create (quantitatively and qualitatively).\n\n### **Setting up R**\n\n-   To run a line of code move your cursor to the line and press ctrl+Enter. To run a chunk of code press the green button at the top right of the chunk. If a a line starts with a #, it is a comment but it can also be used to prevent a line from running. See how I comment out install packages on line 31 since I have already installed this package on my computer.\n\nInstall terra and other packages. Terra is the main library that will let us work with spatial data\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#install.packages(\"terra\")\n#install.packages(\"RStoolbox\")\n#install.packages(\"ggplot2\")\n#install.packages(\"dplyr\")\n#install.packages(\"ggspatial\")\n#install.packages(\"tmap\")\n\nlibrary(terra)\nlibrary(RStoolbox)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggspatial)\nlibrary(tmap)\n```\n:::\n\n\n\n\nLet's figure out where we are and get where we need to be\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#this prints the working directory\ngetwd()\n\n#this sets the working directory\n#setwd(\"/Users/wancher/Documents/rs_485/input_data/\")\n#setwd(\"D:/RemoteSensingLabs/input_data/\")\n```\n:::\n\n\n\n\n### **Reading in data**\n\nRead in a single image\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# the arrow is the same as =\n# replace with your file name\ndir <- \"/Users/wancher/Documents/rs_485/input_data/\"\nr <- rast(paste0(dir,\"landsat_panchro_2023.tif\"))\nr\n```\n:::\n\n\n\n\nThis is how you can plot something\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(r)\n```\n:::\n\n\n\n\nPrint summary statistics and plot a histogram\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(r)\nhist(r)\n```\n:::\n\n\n\n\nThose are the basics of how to read an inspect an image. You can read in your other files the same way. Something like this...\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#sentinel_b2 <- \"landsat8_2024_rawbands.tif\"\n#sentinel_b3 <- \"sentinel_2019_rawbands.tif\"\n```\n:::\n\n\n\n\nOR\n\nWe can read in all of the tiff files from our current working folder and store them in a list\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir <- \"/Users/wancher/Documents/rs_485/input_data\"\nlist_of_files <- list.files(dir, pattern=\"*.tif\", full.names = TRUE)\nlist_of_files\n```\n:::\n\n\n\n\nThis is just a list of the file paths. So let's convert it to list of rasters or SpatRasters as terra puts it\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#lapply means list apply. So perform terra's rast function on a list of items\nlist_of_rasters <- lapply(list_of_files, rast)\n\n#sometimes the names don't transfer properly so you can change them if needed\nnames(list_of_rasters) <- list_of_files\n```\n:::\n\n\n\n\n### **For loops**\n\nWe can write a for loop to do things in iteration. Let's say we want to plot each image in our list of rasters.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#for each each raster in the sequence, do x thing...\nfor (i in seq_along(list_of_rasters)){\n\tone_image <- list_of_rasters[[i]]\n\t\n\t#store the name of the image\n\tfilename <- basename(sources(one_image))\n\tplot(one_image, main = paste0(filename))\n\trm(one_image)\n}\n#this might take a second\n```\n:::\n\n\n\n\n### **Displaying data iteratively**\n\nNow... let's plot in true color using the plotrgb function\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#just one image and band\nplot(list_of_rasters[[1]]) #here I am just reaching into the list of rasters and grabbing the 2nd item and Band 3\nnames(list_of_rasters[[1]])\n\n#just one image in true color\nplotRGB(list_of_rasters[[7]], r=4, g=3, b=2, stretch = \"lin\")\n```\n:::\n\n\n\n\nLet's do the same thing using a for loop over the entire list of rasters. You can decide if you want to use something like a for loop for the later enhancement techniques or if you would prefer to write things out line by line.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#iterate \nfor (raster in list_of_rasters){\n  #if there is more than one band in the raster then...\n  if (nlyr(raster) > 1){\n\t  filename <- varnames(raster)\n\t  \n\t  plotRGB(raster, r=7, g=2, b=4, \n\t          stretch = \"lin\",\n\t          smooth = TRUE,\n\t          main = paste0(\"true color: \", filename))\n\t  \n\t  #otherwise if the image only has one band\n  } else {\n    filename2 <- varnames(raster)\n    plot(raster, main = paste0(\"b8: \", filename2), stretch = \"lin\")\n  }\n}\n```\n:::\n\n\n\n\n**SECTION TURN IN**\n\nQuestion 1: What bands are needed to make a true color image for Landsat 8 and 9?\n\nQuestion 2: Did the Sentinel images plot in true color? What bands are needed for true color with Sentinel 2A?\n\nQuestion 3: Is the \"plotRGB\" function in the above chunk the same as the Build Virtual Raster tool in QGIS? yes/no/why?\n\nQuestion 4: What are different types of stretch methods within the PlotRGB function?\n\nScreenshots: Answers to questions above alongside 3 screenshots. Select one year between 2019 and 2024 and submit a screenshot of the corresponding images in that year. (Should be a landsat true color, sentinel true color, and landsat panchromatic). If your images did not display in true color, you should tweak the arguments in the plotRGB function!\n\n### **Pansharpening**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#print the spatial resolution\nres(list_of_rasters[[1]])\nres(list_of_rasters[[7]])\nres(list_of_rasters[[14]])\n\n#you'll notice that there is a difference in spatial resolution between the landsat raw bands, landsat panchromatic, and sentinel. Since the goal here is to compare across Landsat and Sentinel we will downsample our landsat rawbands to the higher resolution of the panchromatic band (from 30m down to 15m).\n\n#as an example\npanchro_test <- list_of_rasters[[1]]\nlandsat_rawbands_test <- list_of_rasters[[7]]\n\n#be sure to specify the correct bands\nlandsat_rawbands_sharpened <- panSharpen(landsat_rawbands_test, panchro_test, \n                                          r = 5, g = 4, b = 3, method = \"brovey\")\n```\n:::\n\n\n\n\n**SECTION TURN IN**\n\nQuestion 1: What do you think of the result? What happens if you change the method?\n\nQuestion 2: What is the spatial resolution of the panchromatic data compared to the raw bands of Landsat? What about the spatial resolution of Sentinel?\n\nQuestion 3: What units of resolution are your images in?\n\nQuestion 4: Answers to questions and pansharpen one of your Landsat images and submit a screenshot of the result, with a figure caption. I'll let you decide if you would like to pansharpen all of your Landsat images.\n\n### **Constrast stretching**\n\n-   Just as you would photoshop a photo you to enhance the quality or color for sharing on social media or with friends and family, we can do the same thing in remote sensing.\n\n-   Since we know that images are just numbers, we can think of this process as stretching the image values towards the extremes of the data range.\n\nRename the bands so operations only need cast once.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#rename the bands so we can write a universal equation\nband_names_landsat <- c(\"aerosol\", \"blue\", \"green\", \"red\", \"nir\", \"swir1\", \"swir2\")\nband_names_sentinel <- c(\"blue\", \"green\", \"red\", \"rededge1\", \"rededge2\", \"rededge3\", \"nir\", \"rededge4\", \"swir1\", \"swir2\")\n\nrename_bands <- function(raster) {\n  if (\"SR_B1\" %in% names(raster)) {\n    names(raster) <- band_names_landsat\n    return(raster)\n  } else if (\"B2\" %in% names(raster)) {\n    names(raster) <- band_names_sentinel\n    return(raster)\n  } else {\n    return(NULL)\n  }\n}\n\nlist_of_rasters_renamed <- lapply(list_of_rasters, rename_bands)\nlist_of_rasters_renamed <- list_of_rasters_renamed[-c(1:6)]#rm the panchro images\n```\n:::\n\n\n\n\nStretch one image\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_image <- list_of_rasters_renamed[[12]]\nhist(test_image$red)#red for example\nplot(test_image$red)\n\n#the 5th and 80th percentiles of the raster (values which 5% and 80% of the raster fall under)\np_low <- quantile(values(test_image$red), 0.05, na.rm = TRUE)\np_high <- quantile(values(test_image$red), 0.80, na.rm = TRUE) \n\n#limit the range of the raster to these high and low values and change the scale to range from 0 to 1\nr_stretched <- clamp((test_image$red - p_low) / (p_high - p_low), lower = 0, upper = 1)\nplot(r_stretched$red)\nhist(r_stretched$red)\n```\n:::\n\n\n\n\n**SECTION TURN IN**\n\nQuestions: What are your thoughts about the contrast stretch result? Did you try changing the percentile values?\n\nContrast stretch each band in each image\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontrast_stretch <- function(raster_band){\n  p_low <- quantile(values(raster_band), 0.05, na.rm = TRUE)\n  p_high <- quantile(values(raster_band), 0.90, na.rm = TRUE) \n  stretched_band <- clamp((raster_band - p_low) / (p_high - p_low), \n                          lower = 0, upper = 1)\n  return(stretched_band)\n}\n\n#function to apply the stretch to each band and each raster\napply_stretch <- function(raster) {\n  band_names <- names(raster)\n  \n  #apply stretch to each band\n  stretched_bands <- lapply(band_names, function(band_name) {\n    band <- raster[[band_name]]\n    contrast_stretch(band)\n  })\n  #combine stretched bands into one raster\n  stretched_raster <- c(stretched_bands)\n  names(stretched_raster) <- band_names#retain bandnames\n  return(stretched_raster)\n}\n\nlist_of_stretched_rasters <- lapply(list_of_rasters_renamed, apply_stretch)\n```\n:::\n\n\n\n\n### **Calculating vegetation indices**\n\n-   You can now calculate vegetation or other indices on your stretched images.\n\n-   Say you would like to look at vegetation health around Mount St Helens. You can look up things in google like \"how do I compute NDVI for Landsat?\" (assuming you have heard about NDVI), or \"what is a good index to use when monitoring vegetation with Landsat?\" What you will find is that remote sensing scientists have developed equations for answering these types of questions and it is pretty straightforward to apply if you have your data and software ready.\n\n-   In R, we can using simple arithmetic operations to do this. For example, to compute the Normalized Differenced Vegetation Index (NDVI), the equation is like so:\n\n***NDVI = NIR-RED/NIR+RED***\n\nLet's grab an image and try it:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#dollar sign indexing is what this is called \n#i like to follow good ole PEMDAS pretty closely when I do band math just to be cautious\ntest_ndvi <- (r_stretched$B8- r_stretched$B4) / \n             (r_stretched$B8 + r_stretched$B4)\nsummary(test_ndvi)\n\nhist(test_ndvi)\nplot(test_ndvi)\n```\n:::\n\n\n\n\nVisualizing a different way\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#different color palette\nndvi_palette <- colorRampPalette(c(\"#FFFF00\", \"#FF0000\", \"#FF00FF\", \"#0000FF\", \"#639200\"))(100)\n\n#plot\nplot(test_ndvi, col = ndvi_palette, main = \"ndvi sentinel\")\n\n#compare this with true color\nplotRGB(r_stretched, r=3, g=2, b=1, stretch = \"lin\")\n\n#save and take it to qgis\n#writeRaster(test_ndvi, \"/Users/wancher/Documents/rs_485/output_data/ndvi_sentinel_2022.tif\")\n```\n:::\n\n\n\n\n**SECTION TURN IN**\n\nScreenshots: Take a screenshot of the test NDVI you produced in the default color palette, and then define your own color palette (line 317) and submit another screenshot. Mention how this either helped or did not help your interpretation of the data.\n\nLet's write a function to compute ndvi for each image and then apply it to the list of rasters.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#write functions to calculate ndvi\ncalculate_ndvi <- function(raster){\n  ndvi <- (raster$nir - raster$red) / (raster$nir + raster$red)\n  names(ndvi) <- \"ndvi\"\n  return(ndvi)\n}\nlist_of_ndvis <- lapply(list_of_stretched_rasters, calculate_ndvi)\n```\n:::\n\n\n\n\n### **Comparison**\n\n-   You are now going to create graphs to show your indices through time.\n\nHere is an example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#example of how to convert a raster to a dataframe\ndf <- as.data.frame(r) #not going to use it but this is the basic function you need (line 349)\n\n#function to convert rasters to dataframes\nraster_to_dataframe <- function(raster){\n  source <- strsplit(varnames(raster), \"_\")[[1]][1] #split the filename by recognizing the underscore seperator and grab the first element\n  year <- strsplit(varnames(raster), \"_\")[[1]][3]#third element (which is year if you look at the filename)\n  \n  #average and variance\n  df <- as.data.frame(raster, xy = TRUE) %>%\n    summarise(Avg_NDVI = mean(ndvi, na.rm = TRUE),\n              SD_NDVI = sd(ndvi, na.rm = TRUE))\n    \n  df$source <- source #add source column\n  df$year <- as.numeric(year) #add year column\n  \n  return(df)\n}\n\n#convert the list of NDVIs to a list of dataframes so we can graph\nlist_of_dfs <- lapply(list_of_ndvis, raster_to_dataframe)\ncombined_df <- do.call(rbind, list_of_dfs) #rowbind the dataframes into one dataframe\n\n#if you would like to work in excel!\n#write.csv(combined_df, /path/to/output/folder/*.csv, row.names = FALSE)\n```\n:::\n\n\n\n\nPlot\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#plotting through time using ggplot library\nggplot(combined_df, aes(x = year, y = Avg_NDVI, color = source)) +\n  geom_smooth(size = 2) + \n  geom_point(size = 3) + #add points\n  #geom_errorbar(aes(ymin = Avg_NDVI - SD_NDVI, ymax = Avg_NDVI + SD_NDVI), width = 0.2) + \n  labs(title = \"Normalized Difference Vegetation Index in AOI\",\n       x = \"Year\",\n       y = \"Average NDVI\",\n       color = \"Satellite\") +\n  theme_minimal()\n```\n:::\n\n\n\n\n**SECTION TURN IN**\n\nQuestions: Your average NDVI value is an average of what exactly? What would you need to do if you wanted the average NDVI value in a particular spot in your image?\n\nScreenshots: Screenshot or figure with caption showing NDVI through time. Calculate at least 2 additional indices and make similar plots.\n\n### **Difference maps**\n\n-   For your last step you need to calculate take the difference between 2024 and 2019 for each index and satellite.\n\nFor example: ***NDVI_Landsat_2024.tif - NDVI_Landsat_2019.tif***\n\nHere is how I would do it for the NDVI Image. Feel free to use the writeRaster function to export your ndvi images and make a layout in ArcGIS or QGIS if you would be more comfortable there. The ggplot layout is acceptable though!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nndvi_diff <- list_of_ndvis[[12]] - list_of_ndvis[[7]]\n\n#using tmap\nndvi_palette <- c(\"#a50026\", \"#d73027\", \"#f46d43\", \"#fdae61\", \n                  \"#66bd63\", \"#006837\")\ntm_shape(ndvi_diff) +\n  tm_raster(midpoint = NA, style = \"pretty\", palette = ndvi_palette, title = \"Range\") +\n  tm_layout(title = \"Sentinel NDVI Difference (2024 - 2019)\",\n            legend.position = c(\"right\", \"bottom\"),\n            legend.bg.color = \"white\",  #legend background\n            legend.frame = TRUE,  #legend border\n            legend.text.size = 1.2, \n            legend.title.size = 1.4) +\n  tm_compass(size = 2, position = c(\"right\", \"top\")) +  #north arrow\n  tm_scale_bar(text.size = 1, position = c(\"left\", \"bottom\"))  #scale bar\n```\n:::\n\n\n\n\n**SECTION TURN IN**\n\nScreenshots: Maps of index change between 2019 and 2024 for each index. Include a north arrow and scale bar. Use intuitive color palettes. Describe what we are looking at. As always toggle it on and off with true color images to guide your interpretation.\n\n**FINAL SUBMISSION:**\n\nPlease submit...\n\n1)  A PDF write up answering the questions throughout with your screenshots attached\n\n#OR\n\n2)  You can submit this .QMD document ***rendered*** (see top of the script), with \"eval=TRUE\". This will convert the document to an HTML and will run your code. If you select this method you can just type your responses directly beneath the questions. Please submit both the HTML and QMD if you go with this option. You may get an error which is sort of difficult to debug. So I would suggest writing up a PDF to be safe but know that this option exists.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}